{"ast":null,"code":"\"use strict\";\n\n/*\r\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.jsonErr = jsonErr;\nexports.json = json;\nexports.textErr = textErr;\nexports.text = text;\nexports.bytesErr = bytesErr;\nexports.bytes = bytes;\nexports.streamErr = streamErr;\nexports.stream = stream;\nexports.sseErr = sseErr;\nexports.sse = sse;\nexports.nilErr = nilErr;\nexports.nil = nil;\nexports.fail = fail;\nexports.match = match;\nexports.unpackHeaders = unpackHeaders;\nexports.discardResponseBody = discardResponseBody;\nconst sdkerror_js_1 = require(\"../models/errors/sdkerror.js\");\nconst event_streams_js_1 = require(\"./event-streams.js\");\nconst http_js_1 = require(\"./http.js\");\nconst is_plain_object_js_1 = require(\"./is-plain-object.js\");\nconst schemas_js_1 = require(\"./schemas.js\");\nconst DEFAULT_CONTENT_TYPES = {\n  json: \"application/json\",\n  text: \"text/plain\",\n  bytes: \"application/octet-stream\",\n  stream: \"application/octet-stream\",\n  sse: \"text/event-stream\",\n  nil: \"*\",\n  fail: \"*\"\n};\nfunction jsonErr(codes, schema, options) {\n  return {\n    ...options,\n    err: true,\n    enc: \"json\",\n    codes,\n    schema\n  };\n}\nfunction json(codes, schema, options) {\n  return {\n    ...options,\n    enc: \"json\",\n    codes,\n    schema\n  };\n}\nfunction textErr(codes, schema, options) {\n  return {\n    ...options,\n    err: true,\n    enc: \"text\",\n    codes,\n    schema\n  };\n}\nfunction text(codes, schema, options) {\n  return {\n    ...options,\n    enc: \"text\",\n    codes,\n    schema\n  };\n}\nfunction bytesErr(codes, schema, options) {\n  return {\n    ...options,\n    err: true,\n    enc: \"bytes\",\n    codes,\n    schema\n  };\n}\nfunction bytes(codes, schema, options) {\n  return {\n    ...options,\n    enc: \"bytes\",\n    codes,\n    schema\n  };\n}\nfunction streamErr(codes, schema, options) {\n  return {\n    ...options,\n    err: true,\n    enc: \"stream\",\n    codes,\n    schema\n  };\n}\nfunction stream(codes, schema, options) {\n  return {\n    ...options,\n    enc: \"stream\",\n    codes,\n    schema\n  };\n}\nfunction sseErr(codes, schema, options) {\n  return {\n    ...options,\n    err: true,\n    enc: \"sse\",\n    codes,\n    schema\n  };\n}\nfunction sse(codes, schema, options) {\n  return {\n    ...options,\n    enc: \"sse\",\n    codes,\n    schema\n  };\n}\nfunction nilErr(codes, schema, options) {\n  return {\n    ...options,\n    err: true,\n    enc: \"nil\",\n    codes,\n    schema\n  };\n}\nfunction nil(codes, schema, options) {\n  return {\n    ...options,\n    enc: \"nil\",\n    codes,\n    schema\n  };\n}\nfunction fail(codes) {\n  return {\n    enc: \"fail\",\n    codes\n  };\n}\nfunction match(...matchers) {\n  return async function matchFunc(response, options) {\n    let raw;\n    let matcher;\n    for (const match of matchers) {\n      const {\n        codes\n      } = match;\n      const ctpattern = \"ctype\" in match ? match.ctype : DEFAULT_CONTENT_TYPES[match.enc];\n      if (ctpattern && (0, http_js_1.matchResponse)(response, codes, ctpattern)) {\n        matcher = match;\n        break;\n      } else if (!ctpattern && (0, http_js_1.matchStatusCode)(response, codes)) {\n        matcher = match;\n        break;\n      }\n    }\n    if (!matcher) {\n      const responseBody = await response.text();\n      return [{\n        ok: false,\n        error: new sdkerror_js_1.SDKError(\"Unexpected API response status or content-type\", response, responseBody)\n      }, responseBody];\n    }\n    const encoding = matcher.enc;\n    switch (encoding) {\n      case \"json\":\n        raw = await response.json();\n        break;\n      case \"bytes\":\n        raw = await response.arrayBuffer();\n        break;\n      case \"stream\":\n        raw = response.body;\n        break;\n      case \"text\":\n        raw = await response.text();\n        break;\n      case \"sse\":\n        raw = response.body && matcher.sseSentinel ? (0, event_streams_js_1.discardSentinel)(response.body, matcher.sseSentinel) : response.body;\n        break;\n      case \"nil\":\n        raw = await discardResponseBody(response);\n        break;\n      case \"fail\":\n        raw = await response.text();\n        break;\n      default:\n        encoding;\n        throw new Error(`Unsupported response type: ${encoding}`);\n    }\n    if (matcher.enc === \"fail\") {\n      return [{\n        ok: false,\n        error: new sdkerror_js_1.SDKError(\"API error occurred\", response, typeof raw === \"string\" ? raw : \"\")\n      }, raw];\n    }\n    const resultKey = matcher.key || (options === null || options === void 0 ? void 0 : options.resultKey);\n    let data;\n    if (\"err\" in matcher) {\n      data = {\n        ...(options === null || options === void 0 ? void 0 : options.extraFields),\n        ...(matcher.hdrs ? {\n          Headers: unpackHeaders(response.headers)\n        } : null),\n        ...((0, is_plain_object_js_1.isPlainObject)(raw) ? raw : null)\n      };\n    } else if (resultKey) {\n      data = {\n        ...(options === null || options === void 0 ? void 0 : options.extraFields),\n        ...(matcher.hdrs ? {\n          Headers: unpackHeaders(response.headers)\n        } : null),\n        [resultKey]: raw\n      };\n    } else if (matcher.hdrs) {\n      data = {\n        ...(options === null || options === void 0 ? void 0 : options.extraFields),\n        ...(matcher.hdrs ? {\n          Headers: unpackHeaders(response.headers)\n        } : null),\n        ...((0, is_plain_object_js_1.isPlainObject)(raw) ? raw : null)\n      };\n    } else {\n      data = raw;\n    }\n    if (\"err\" in matcher) {\n      const result = (0, schemas_js_1.safeParse)(data, v => matcher.schema.parse(v), \"Response validation failed\");\n      return [result.ok ? {\n        ok: false,\n        error: result.value\n      } : result, raw];\n    } else {\n      return [(0, schemas_js_1.safeParse)(data, v => matcher.schema.parse(v), \"Response validation failed\"), raw];\n    }\n  };\n}\nconst headerValRE = /, */;\n/**\r\n * Iterates over a Headers object and returns an object with all the header\r\n * entries. Values are represented as an array to account for repeated headers.\r\n */\nfunction unpackHeaders(headers) {\n  const out = {};\n  for (const [k, v] of headers.entries()) {\n    out[k] = v.split(headerValRE);\n  }\n  return out;\n}\n/**\r\n * Discards the response body to free up resources.\r\n *\r\n * To learn why this is need, see the undici docs:\r\n * https://undici.nodejs.org/#/?id=garbage-collection\r\n */\nasync function discardResponseBody(res) {\n  var _a;\n  const reader = (_a = res.body) === null || _a === void 0 ? void 0 : _a.getReader();\n  if (reader == null) {\n    return;\n  }\n  try {\n    let done = false;\n    while (!done) {\n      const res = await reader.read();\n      done = res.done;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}","map":{"version":3,"names":["exports","jsonErr","json","textErr","text","bytesErr","bytes","streamErr","stream","sseErr","sse","nilErr","nil","fail","match","unpackHeaders","discardResponseBody","sdkerror_js_1","require","event_streams_js_1","http_js_1","is_plain_object_js_1","schemas_js_1","DEFAULT_CONTENT_TYPES","codes","schema","options","err","enc","matchers","matchFunc","response","raw","matcher","ctpattern","ctype","matchResponse","matchStatusCode","responseBody","ok","error","SDKError","encoding","arrayBuffer","body","sseSentinel","discardSentinel","Error","resultKey","key","data","extraFields","hdrs","Headers","headers","isPlainObject","result","safeParse","v","parse","value","headerValRE","out","k","entries","split","res","reader","_a","getReader","done","read","releaseLock"],"sources":["C:\\Users\\silvi\\OneDrive\\Escritorio\\LUISDEEEE\\School of code\\WEEK 12 FINAL HACKATON\\HistoriansRule\\node_modules\\@mistralai\\mistralai\\src\\lib\\matchers.ts"],"sourcesContent":["/*\r\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\r\n */\r\n\r\nimport { SDKError } from \"../models/errors/sdkerror.js\";\r\nimport { SDKValidationError } from \"../models/errors/sdkvalidationerror.js\";\r\nimport { Result } from \"../types/fp.js\";\r\nimport { discardSentinel } from \"./event-streams.js\";\r\nimport { matchResponse, matchStatusCode, StatusCodePredicate } from \"./http.js\";\r\nimport { isPlainObject } from \"./is-plain-object.js\";\r\nimport { safeParse } from \"./schemas.js\";\r\n\r\nexport type Encoding =\r\n  | \"json\"\r\n  | \"text\"\r\n  | \"bytes\"\r\n  | \"stream\"\r\n  | \"sse\"\r\n  | \"nil\"\r\n  | \"fail\";\r\n\r\nconst DEFAULT_CONTENT_TYPES: Record<Encoding, string> = {\r\n  json: \"application/json\",\r\n  text: \"text/plain\",\r\n  bytes: \"application/octet-stream\",\r\n  stream: \"application/octet-stream\",\r\n  sse: \"text/event-stream\",\r\n  nil: \"*\",\r\n  fail: \"*\",\r\n};\r\n\r\ntype Schema<T> = { parse(raw: unknown): T };\r\n\r\ntype MatchOptions = {\r\n  ctype?: string;\r\n  hdrs?: boolean;\r\n  key?: string;\r\n  sseSentinel?: string;\r\n};\r\n\r\nexport type ValueMatcher<V> = MatchOptions & {\r\n  enc: Encoding;\r\n  codes: StatusCodePredicate;\r\n  schema: Schema<V>;\r\n};\r\n\r\nexport type ErrorMatcher<E> = MatchOptions & {\r\n  enc: Encoding;\r\n  codes: StatusCodePredicate;\r\n  schema: Schema<E>;\r\n  err: true;\r\n};\r\n\r\nexport type FailMatcher = {\r\n  enc: \"fail\";\r\n  codes: StatusCodePredicate;\r\n};\r\n\r\nexport type Matcher<T, E> = ValueMatcher<T> | ErrorMatcher<E> | FailMatcher;\r\n\r\nexport function jsonErr<E>(\r\n  codes: StatusCodePredicate,\r\n  schema: Schema<E>,\r\n  options?: MatchOptions,\r\n): ErrorMatcher<E> {\r\n  return { ...options, err: true, enc: \"json\", codes, schema };\r\n}\r\nexport function json<T>(\r\n  codes: StatusCodePredicate,\r\n  schema: Schema<T>,\r\n  options?: MatchOptions,\r\n): ValueMatcher<T> {\r\n  return { ...options, enc: \"json\", codes, schema };\r\n}\r\n\r\nexport function textErr<E>(\r\n  codes: StatusCodePredicate,\r\n  schema: Schema<E>,\r\n  options?: MatchOptions,\r\n): ErrorMatcher<E> {\r\n  return { ...options, err: true, enc: \"text\", codes, schema };\r\n}\r\nexport function text<T>(\r\n  codes: StatusCodePredicate,\r\n  schema: Schema<T>,\r\n  options?: MatchOptions,\r\n): ValueMatcher<T> {\r\n  return { ...options, enc: \"text\", codes, schema };\r\n}\r\n\r\nexport function bytesErr<E>(\r\n  codes: StatusCodePredicate,\r\n  schema: Schema<E>,\r\n  options?: MatchOptions,\r\n): ErrorMatcher<E> {\r\n  return { ...options, err: true, enc: \"bytes\", codes, schema };\r\n}\r\nexport function bytes<T>(\r\n  codes: StatusCodePredicate,\r\n  schema: Schema<T>,\r\n  options?: MatchOptions,\r\n): ValueMatcher<T> {\r\n  return { ...options, enc: \"bytes\", codes, schema };\r\n}\r\n\r\nexport function streamErr<E>(\r\n  codes: StatusCodePredicate,\r\n  schema: Schema<E>,\r\n  options?: MatchOptions,\r\n): ErrorMatcher<E> {\r\n  return { ...options, err: true, enc: \"stream\", codes, schema };\r\n}\r\nexport function stream<T>(\r\n  codes: StatusCodePredicate,\r\n  schema: Schema<T>,\r\n  options?: MatchOptions,\r\n): ValueMatcher<T> {\r\n  return { ...options, enc: \"stream\", codes, schema };\r\n}\r\n\r\nexport function sseErr<E>(\r\n  codes: StatusCodePredicate,\r\n  schema: Schema<E>,\r\n  options?: MatchOptions,\r\n): ErrorMatcher<E> {\r\n  return { ...options, err: true, enc: \"sse\", codes, schema };\r\n}\r\nexport function sse<T>(\r\n  codes: StatusCodePredicate,\r\n  schema: Schema<T>,\r\n  options?: MatchOptions,\r\n): ValueMatcher<T> {\r\n  return { ...options, enc: \"sse\", codes, schema };\r\n}\r\n\r\nexport function nilErr<E>(\r\n  codes: StatusCodePredicate,\r\n  schema: Schema<E>,\r\n  options?: MatchOptions,\r\n): ErrorMatcher<E> {\r\n  return { ...options, err: true, enc: \"nil\", codes, schema };\r\n}\r\nexport function nil<T>(\r\n  codes: StatusCodePredicate,\r\n  schema: Schema<T>,\r\n  options?: MatchOptions,\r\n): ValueMatcher<T> {\r\n  return { ...options, enc: \"nil\", codes, schema };\r\n}\r\n\r\nexport function fail(codes: StatusCodePredicate): FailMatcher {\r\n  return { enc: \"fail\", codes };\r\n}\r\n\r\nexport type MatchedValue<Matchers> = Matchers extends Matcher<infer T, any>[]\r\n  ? T\r\n  : never;\r\nexport type MatchedError<Matchers> = Matchers extends Matcher<any, infer E>[]\r\n  ? E\r\n  : never;\r\nexport type MatchFunc<T, E> = (\r\n  response: Response,\r\n  options?: { resultKey?: string; extraFields?: Record<string, unknown> },\r\n) => Promise<[result: Result<T, E>, raw: unknown]>;\r\n\r\nexport function match<T, E>(\r\n  ...matchers: Array<Matcher<T, E>>\r\n): MatchFunc<T, E | SDKError | SDKValidationError> {\r\n  return async function matchFunc(\r\n    response: Response,\r\n    options?: { resultKey?: string; extraFields?: Record<string, unknown> },\r\n  ): Promise<\r\n    [result: Result<T, E | SDKError | SDKValidationError>, raw: unknown]\r\n  > {\r\n    let raw: unknown;\r\n    let matcher: Matcher<T, E> | undefined;\r\n    for (const match of matchers) {\r\n      const { codes } = match;\r\n      const ctpattern = \"ctype\" in match\r\n        ? match.ctype\r\n        : DEFAULT_CONTENT_TYPES[match.enc];\r\n      if (ctpattern && matchResponse(response, codes, ctpattern)) {\r\n        matcher = match;\r\n        break;\r\n      } else if (!ctpattern && matchStatusCode(response, codes)) {\r\n        matcher = match;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (!matcher) {\r\n      const responseBody = await response.text();\r\n      return [{\r\n        ok: false,\r\n        error: new SDKError(\r\n          \"Unexpected API response status or content-type\",\r\n          response,\r\n          responseBody,\r\n        ),\r\n      }, responseBody];\r\n    }\r\n\r\n    const encoding = matcher.enc;\r\n    switch (encoding) {\r\n      case \"json\":\r\n        raw = await response.json();\r\n        break;\r\n      case \"bytes\":\r\n        raw = await response.arrayBuffer();\r\n        break;\r\n      case \"stream\":\r\n        raw = response.body;\r\n        break;\r\n      case \"text\":\r\n        raw = await response.text();\r\n        break;\r\n      case \"sse\":\r\n        raw = response.body && matcher.sseSentinel\r\n          ? discardSentinel(response.body, matcher.sseSentinel)\r\n          : response.body;\r\n        break;\r\n      case \"nil\":\r\n        raw = await discardResponseBody(response);\r\n        break;\r\n      case \"fail\":\r\n        raw = await response.text();\r\n        break;\r\n      default:\r\n        encoding satisfies never;\r\n        throw new Error(`Unsupported response type: ${encoding}`);\r\n    }\r\n\r\n    if (matcher.enc === \"fail\") {\r\n      return [{\r\n        ok: false,\r\n        error: new SDKError(\r\n          \"API error occurred\",\r\n          response,\r\n          typeof raw === \"string\" ? raw : \"\",\r\n        ),\r\n      }, raw];\r\n    }\r\n\r\n    const resultKey = matcher.key || options?.resultKey;\r\n    let data: unknown;\r\n\r\n    if (\"err\" in matcher) {\r\n      data = {\r\n        ...options?.extraFields,\r\n        ...(matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null),\r\n        ...(isPlainObject(raw) ? raw : null),\r\n      };\r\n    } else if (resultKey) {\r\n      data = {\r\n        ...options?.extraFields,\r\n        ...(matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null),\r\n        [resultKey]: raw,\r\n      };\r\n    } else if (matcher.hdrs) {\r\n      data = {\r\n        ...options?.extraFields,\r\n        ...(matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null),\r\n        ...(isPlainObject(raw) ? raw : null),\r\n      };\r\n    } else {\r\n      data = raw;\r\n    }\r\n\r\n    if (\"err\" in matcher) {\r\n      const result = safeParse(\r\n        data,\r\n        (v: unknown) => matcher.schema.parse(v),\r\n        \"Response validation failed\",\r\n      );\r\n      return [result.ok ? { ok: false, error: result.value } : result, raw];\r\n    } else {\r\n      return [\r\n        safeParse(\r\n          data,\r\n          (v: unknown) => matcher.schema.parse(v),\r\n          \"Response validation failed\",\r\n        ),\r\n        raw,\r\n      ];\r\n    }\r\n  };\r\n}\r\n\r\nconst headerValRE = /, */;\r\n/**\r\n * Iterates over a Headers object and returns an object with all the header\r\n * entries. Values are represented as an array to account for repeated headers.\r\n */\r\nexport function unpackHeaders(headers: Headers): Record<string, string[]> {\r\n  const out: Record<string, string[]> = {};\r\n\r\n  for (const [k, v] of headers.entries()) {\r\n    out[k] = v.split(headerValRE);\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Discards the response body to free up resources.\r\n *\r\n * To learn why this is need, see the undici docs:\r\n * https://undici.nodejs.org/#/?id=garbage-collection\r\n */\r\nexport async function discardResponseBody(res: Response) {\r\n  const reader = res.body?.getReader();\r\n  if (reader == null) {\r\n    return;\r\n  }\r\n\r\n  try {\r\n    let done = false;\r\n    while (!done) {\r\n      const res = await reader.read();\r\n      done = res.done;\r\n    }\r\n  } finally {\r\n    reader.releaseLock();\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}