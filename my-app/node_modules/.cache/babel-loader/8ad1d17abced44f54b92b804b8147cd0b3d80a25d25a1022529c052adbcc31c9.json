{"ast":null,"code":"\"use strict\";\n\n/*\r\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeDeepObjectQuery = exports.encodePipeDelimitedQuery = exports.encodeSpaceDelimitedQuery = exports.encodeFormQuery = exports.encodeJSONQuery = exports.encodeSimple = exports.encodePipeDelimited = exports.encodeSpaceDelimited = exports.encodeForm = exports.EncodingError = void 0;\nexports.encodeMatrix = encodeMatrix;\nexports.encodeLabel = encodeLabel;\nexports.encodeBodyForm = encodeBodyForm;\nexports.encodeDeepObject = encodeDeepObject;\nexports.encodeDeepObjectObject = encodeDeepObjectObject;\nexports.encodeJSON = encodeJSON;\nexports.queryJoin = queryJoin;\nexports.queryEncoder = queryEncoder;\nconst base64_js_1 = require(\"./base64.js\");\nconst is_plain_object_js_1 = require(\"./is-plain-object.js\");\nclass EncodingError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"EncodingError\";\n  }\n}\nexports.EncodingError = EncodingError;\nfunction encodeMatrix(key, value, options) {\n  let out = \"\";\n  const pairs = (options === null || options === void 0 ? void 0 : options.explode) ? explode(key, value) : [[key, value]];\n  const encodeString = v => {\n    return (options === null || options === void 0 ? void 0 : options.charEncoding) === \"percent\" ? encodeURIComponent(v) : v;\n  };\n  const encodeValue = v => encodeString(serializeValue(v));\n  pairs.forEach(([pk, pv]) => {\n    let tmp = \"\";\n    let encValue = \"\";\n    if (pv === undefined) {\n      return;\n    } else if (Array.isArray(pv)) {\n      encValue = mapDefined(pv, v => `${encodeValue(v)}`).join(\",\");\n    } else if ((0, is_plain_object_js_1.isPlainObject)(pv)) {\n      encValue = mapDefinedEntries(Object.entries(pv), ([k, v]) => {\n        return `,${encodeString(k)},${encodeValue(v)}`;\n      }).join(\"\");\n      encValue = encValue.slice(1);\n    } else {\n      encValue = `${encodeValue(pv)}`;\n    }\n    const keyPrefix = encodeString(pk);\n    tmp = `${keyPrefix}=${encValue}`;\n    // trim trailing '=' if value was empty\n    if (tmp === `${keyPrefix}=`) {\n      tmp = tmp.slice(0, -1);\n    }\n    // If we end up with the nothing then skip forward\n    if (!tmp) {\n      return;\n    }\n    out += `;${tmp}`;\n  });\n  return out;\n}\nfunction encodeLabel(key, value, options) {\n  let out = \"\";\n  const pairs = (options === null || options === void 0 ? void 0 : options.explode) ? explode(key, value) : [[key, value]];\n  const encodeString = v => {\n    return (options === null || options === void 0 ? void 0 : options.charEncoding) === \"percent\" ? encodeURIComponent(v) : v;\n  };\n  const encodeValue = v => encodeString(serializeValue(v));\n  pairs.forEach(([pk, pv]) => {\n    let encValue = \"\";\n    if (pv === undefined) {\n      return;\n    } else if (Array.isArray(pv)) {\n      encValue = mapDefined(pv, v => `${encodeValue(v)}`).join(\".\");\n    } else if ((0, is_plain_object_js_1.isPlainObject)(pv)) {\n      encValue = mapDefinedEntries(Object.entries(pv), ([k, v]) => {\n        return `.${encodeString(k)}.${encodeValue(v)}`;\n      }).join(\"\");\n      encValue = encValue.slice(1);\n    } else {\n      const k = (options === null || options === void 0 ? void 0 : options.explode) && (0, is_plain_object_js_1.isPlainObject)(value) ? `${encodeString(pk)}=` : \"\";\n      encValue = `${k}${encodeValue(pv)}`;\n    }\n    out += `.${encValue}`;\n  });\n  return out;\n}\nfunction formEncoder(sep) {\n  return (key, value, options) => {\n    let out = \"\";\n    const pairs = (options === null || options === void 0 ? void 0 : options.explode) ? explode(key, value) : [[key, value]];\n    const encodeString = v => {\n      return (options === null || options === void 0 ? void 0 : options.charEncoding) === \"percent\" ? encodeURIComponent(v) : v;\n    };\n    const encodeValue = v => encodeString(serializeValue(v));\n    const encodedSep = encodeString(sep);\n    pairs.forEach(([pk, pv]) => {\n      let tmp = \"\";\n      let encValue = \"\";\n      if (pv === undefined) {\n        return;\n      } else if (Array.isArray(pv)) {\n        encValue = mapDefined(pv, v => `${encodeValue(v)}`).join(encodedSep);\n      } else if ((0, is_plain_object_js_1.isPlainObject)(pv)) {\n        encValue = mapDefinedEntries(Object.entries(pv), ([k, v]) => {\n          return `${encodeString(k)}${encodedSep}${encodeValue(v)}`;\n        }).join(encodedSep);\n      } else {\n        encValue = `${encodeValue(pv)}`;\n      }\n      tmp = `${encodeString(pk)}=${encValue}`;\n      // If we end up with the nothing then skip forward\n      if (!tmp || tmp === \"=\") {\n        return;\n      }\n      out += `&${tmp}`;\n    });\n    return out.slice(1);\n  };\n}\nexports.encodeForm = formEncoder(\",\");\nexports.encodeSpaceDelimited = formEncoder(\" \");\nexports.encodePipeDelimited = formEncoder(\"|\");\nfunction encodeBodyForm(key, value, options) {\n  let out = \"\";\n  const pairs = (options === null || options === void 0 ? void 0 : options.explode) ? explode(key, value) : [[key, value]];\n  const encodeString = v => {\n    return (options === null || options === void 0 ? void 0 : options.charEncoding) === \"percent\" ? encodeURIComponent(v) : v;\n  };\n  const encodeValue = v => encodeString(serializeValue(v));\n  pairs.forEach(([pk, pv]) => {\n    let tmp = \"\";\n    let encValue = \"\";\n    if (pv === undefined) {\n      return;\n    } else if (Array.isArray(pv)) {\n      encValue = JSON.stringify(pv, jsonReplacer);\n    } else if ((0, is_plain_object_js_1.isPlainObject)(pv)) {\n      encValue = JSON.stringify(pv, jsonReplacer);\n    } else {\n      encValue = `${encodeValue(pv)}`;\n    }\n    tmp = `${encodeString(pk)}=${encValue}`;\n    // If we end up with the nothing then skip forward\n    if (!tmp || tmp === \"=\") {\n      return;\n    }\n    out += `&${tmp}`;\n  });\n  return out.slice(1);\n}\nfunction encodeDeepObject(key, value, options) {\n  if (value == null) {\n    return \"\";\n  }\n  if (!(0, is_plain_object_js_1.isPlainObject)(value)) {\n    throw new EncodingError(`Value of parameter '${key}' which uses deepObject encoding must be an object`);\n  }\n  return encodeDeepObjectObject(key, value, options);\n}\nfunction encodeDeepObjectObject(key, value, options) {\n  if (value == null) {\n    return \"\";\n  }\n  let out = \"\";\n  const encodeString = v => {\n    return (options === null || options === void 0 ? void 0 : options.charEncoding) === \"percent\" ? encodeURIComponent(v) : v;\n  };\n  if (!(0, is_plain_object_js_1.isPlainObject)(value)) {\n    throw new EncodingError(`Expected parameter '${key}' to be an object.`);\n  }\n  Object.entries(value).forEach(([ck, cv]) => {\n    if (cv === undefined) {\n      return;\n    }\n    const pk = `${key}[${ck}]`;\n    if ((0, is_plain_object_js_1.isPlainObject)(cv)) {\n      const objOut = encodeDeepObjectObject(pk, cv, options);\n      out += `&${objOut}`;\n      return;\n    }\n    const pairs = Array.isArray(cv) ? cv : [cv];\n    let encoded = \"\";\n    encoded = mapDefined(pairs, v => {\n      return `${encodeString(pk)}=${encodeString(serializeValue(v))}`;\n    }).join(\"&\");\n    out += `&${encoded}`;\n  });\n  return out.slice(1);\n}\nfunction encodeJSON(key, value, options) {\n  if (typeof value === \"undefined\") {\n    return \"\";\n  }\n  const encodeString = v => {\n    return (options === null || options === void 0 ? void 0 : options.charEncoding) === \"percent\" ? encodeURIComponent(v) : v;\n  };\n  const encVal = encodeString(JSON.stringify(value, jsonReplacer));\n  return (options === null || options === void 0 ? void 0 : options.explode) ? encVal : `${encodeString(key)}=${encVal}`;\n}\nconst encodeSimple = (key, value, options) => {\n  let out = \"\";\n  const pairs = (options === null || options === void 0 ? void 0 : options.explode) ? explode(key, value) : [[key, value]];\n  const encodeString = v => {\n    return (options === null || options === void 0 ? void 0 : options.charEncoding) === \"percent\" ? encodeURIComponent(v) : v;\n  };\n  const encodeValue = v => encodeString(serializeValue(v));\n  pairs.forEach(([pk, pv]) => {\n    let tmp = \"\";\n    if (pv === undefined) {\n      return;\n    } else if (Array.isArray(pv)) {\n      tmp = mapDefined(pv, v => `${encodeValue(v)}`).join(\",\");\n    } else if ((0, is_plain_object_js_1.isPlainObject)(pv)) {\n      tmp = mapDefinedEntries(Object.entries(pv), ([k, v]) => {\n        return `,${encodeString(k)},${encodeValue(v)}`;\n      }).join(\"\");\n      tmp = tmp.slice(1);\n    } else {\n      const k = (options === null || options === void 0 ? void 0 : options.explode) && (0, is_plain_object_js_1.isPlainObject)(value) ? `${pk}=` : \"\";\n      tmp = `${k}${encodeValue(pv)}`;\n    }\n    // If we end up with the nothing then skip forward\n    if (!tmp) {\n      return;\n    }\n    out += `,${tmp}`;\n  });\n  return out.slice(1);\n};\nexports.encodeSimple = encodeSimple;\nfunction explode(key, value) {\n  if (Array.isArray(value)) {\n    return value.map(v => [key, v]);\n  } else if ((0, is_plain_object_js_1.isPlainObject)(value)) {\n    const o = value !== null && value !== void 0 ? value : {};\n    return Object.entries(o).map(([k, v]) => [k, v]);\n  } else {\n    return [[key, value]];\n  }\n}\nfunction serializeValue(value) {\n  if (value === null) {\n    return \"null\";\n  } else if (typeof value === \"undefined\") {\n    return \"\";\n  } else if (value instanceof Date) {\n    return value.toISOString();\n  } else if (value instanceof Uint8Array) {\n    return (0, base64_js_1.bytesToBase64)(value);\n  } else if (typeof value === \"object\") {\n    return JSON.stringify(value, jsonReplacer);\n  }\n  return `${value}`;\n}\nfunction jsonReplacer(_, value) {\n  if (value instanceof Uint8Array) {\n    return (0, base64_js_1.bytesToBase64)(value);\n  } else {\n    return value;\n  }\n}\nfunction mapDefined(inp, mapper) {\n  return inp.reduce((acc, v) => {\n    if (v === undefined) {\n      return acc;\n    }\n    const m = mapper(v);\n    if (m === undefined) {\n      return acc;\n    }\n    acc.push(m);\n    return acc;\n  }, []);\n}\nfunction mapDefinedEntries(inp, mapper) {\n  const acc = [];\n  for (const [k, v] of inp) {\n    if (v === undefined) {\n      continue;\n    }\n    const m = mapper([k, v]);\n    if (m === undefined) {\n      continue;\n    }\n    acc.push(m);\n  }\n  return acc;\n}\nfunction queryJoin(...args) {\n  return args.filter(Boolean).join(\"&\");\n}\nfunction queryEncoder(f) {\n  const bulkEncode = function (values, options) {\n    var _a, _b;\n    const opts = {\n      ...options,\n      explode: (_a = options === null || options === void 0 ? void 0 : options.explode) !== null && _a !== void 0 ? _a : true,\n      charEncoding: (_b = options === null || options === void 0 ? void 0 : options.charEncoding) !== null && _b !== void 0 ? _b : \"percent\"\n    };\n    const encoded = Object.entries(values).map(([key, value]) => {\n      return f(key, value, opts);\n    });\n    return queryJoin(...encoded);\n  };\n  return bulkEncode;\n}\nexports.encodeJSONQuery = queryEncoder(encodeJSON);\nexports.encodeFormQuery = queryEncoder(exports.encodeForm);\nexports.encodeSpaceDelimitedQuery = queryEncoder(exports.encodeSpaceDelimited);\nexports.encodePipeDelimitedQuery = queryEncoder(exports.encodePipeDelimited);\nexports.encodeDeepObjectQuery = queryEncoder(encodeDeepObject);","map":{"version":3,"names":["exports","encodeMatrix","encodeLabel","encodeBodyForm","encodeDeepObject","encodeDeepObjectObject","encodeJSON","queryJoin","queryEncoder","base64_js_1","require","is_plain_object_js_1","EncodingError","Error","constructor","message","name","key","value","options","out","pairs","explode","encodeString","v","charEncoding","encodeURIComponent","encodeValue","serializeValue","forEach","pk","pv","tmp","encValue","undefined","Array","isArray","mapDefined","join","isPlainObject","mapDefinedEntries","Object","entries","k","slice","keyPrefix","formEncoder","sep","encodedSep","encodeForm","encodeSpaceDelimited","encodePipeDelimited","JSON","stringify","jsonReplacer","ck","cv","objOut","encoded","encVal","encodeSimple","map","o","Date","toISOString","Uint8Array","bytesToBase64","_","inp","mapper","reduce","acc","m","push","args","filter","Boolean","f","bulkEncode","values","opts","_a","_b","encodeJSONQuery","encodeFormQuery","encodeSpaceDelimitedQuery","encodePipeDelimitedQuery","encodeDeepObjectQuery"],"sources":["C:\\Users\\silvi\\OneDrive\\Escritorio\\LUISDEEEE\\School of code\\week 13\\final-project-the-visualisers\\node_modules\\@mistralai\\mistralai\\src\\lib\\encodings.ts"],"sourcesContent":["/*\r\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\r\n */\r\n\r\nimport { bytesToBase64 } from \"./base64.js\";\r\nimport { isPlainObject } from \"./is-plain-object.js\";\r\n\r\nexport class EncodingError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = \"EncodingError\";\r\n  }\r\n}\r\n\r\nexport function encodeMatrix(\r\n  key: string,\r\n  value: unknown,\r\n  options?: { explode?: boolean; charEncoding?: \"percent\" | \"none\" },\r\n): string {\r\n  let out = \"\";\r\n  const pairs: [string, unknown][] = options?.explode\r\n    ? explode(key, value)\r\n    : [[key, value]];\r\n\r\n  const encodeString = (v: string) => {\r\n    return options?.charEncoding === \"percent\" ? encodeURIComponent(v) : v;\r\n  };\r\n  const encodeValue = (v: unknown) => encodeString(serializeValue(v));\r\n\r\n  pairs.forEach(([pk, pv]) => {\r\n    let tmp = \"\";\r\n    let encValue = \"\";\r\n\r\n    if (pv === undefined) {\r\n      return;\r\n    } else if (Array.isArray(pv)) {\r\n      encValue = mapDefined(pv, (v) => `${encodeValue(v)}`).join(\",\");\r\n    } else if (isPlainObject(pv)) {\r\n      encValue = mapDefinedEntries(Object.entries(pv), ([k, v]) => {\r\n        return `,${encodeString(k)},${encodeValue(v)}`;\r\n      }).join(\"\");\r\n      encValue = encValue.slice(1);\r\n    } else {\r\n      encValue = `${encodeValue(pv)}`;\r\n    }\r\n\r\n    const keyPrefix = encodeString(pk);\r\n    tmp = `${keyPrefix}=${encValue}`;\r\n    // trim trailing '=' if value was empty\r\n    if (tmp === `${keyPrefix}=`) {\r\n      tmp = tmp.slice(0, -1);\r\n    }\r\n\r\n    // If we end up with the nothing then skip forward\r\n    if (!tmp) {\r\n      return;\r\n    }\r\n\r\n    out += `;${tmp}`;\r\n  });\r\n\r\n  return out;\r\n}\r\n\r\nexport function encodeLabel(\r\n  key: string,\r\n  value: unknown,\r\n  options?: { explode?: boolean; charEncoding?: \"percent\" | \"none\" },\r\n): string {\r\n  let out = \"\";\r\n  const pairs: [string, unknown][] = options?.explode\r\n    ? explode(key, value)\r\n    : [[key, value]];\r\n\r\n  const encodeString = (v: string) => {\r\n    return options?.charEncoding === \"percent\" ? encodeURIComponent(v) : v;\r\n  };\r\n  const encodeValue = (v: unknown) => encodeString(serializeValue(v));\r\n\r\n  pairs.forEach(([pk, pv]) => {\r\n    let encValue = \"\";\r\n\r\n    if (pv === undefined) {\r\n      return;\r\n    } else if (Array.isArray(pv)) {\r\n      encValue = mapDefined(pv, (v) => `${encodeValue(v)}`).join(\".\");\r\n    } else if (isPlainObject(pv)) {\r\n      encValue = mapDefinedEntries(Object.entries(pv), ([k, v]) => {\r\n        return `.${encodeString(k)}.${encodeValue(v)}`;\r\n      }).join(\"\");\r\n      encValue = encValue.slice(1);\r\n    } else {\r\n      const k =\r\n        options?.explode && isPlainObject(value) ? `${encodeString(pk)}=` : \"\";\r\n      encValue = `${k}${encodeValue(pv)}`;\r\n    }\r\n\r\n    out += `.${encValue}`;\r\n  });\r\n\r\n  return out;\r\n}\r\n\r\ntype FormEncoder = (\r\n  key: string,\r\n  value: unknown,\r\n  options?: { explode?: boolean; charEncoding?: \"percent\" | \"none\" },\r\n) => string;\r\n\r\nfunction formEncoder(sep: string): FormEncoder {\r\n  return (\r\n    key: string,\r\n    value: unknown,\r\n    options?: { explode?: boolean; charEncoding?: \"percent\" | \"none\" },\r\n  ) => {\r\n    let out = \"\";\r\n    const pairs: [string, unknown][] = options?.explode\r\n      ? explode(key, value)\r\n      : [[key, value]];\r\n\r\n    const encodeString = (v: string) => {\r\n      return options?.charEncoding === \"percent\" ? encodeURIComponent(v) : v;\r\n    };\r\n\r\n    const encodeValue = (v: unknown) => encodeString(serializeValue(v));\r\n\r\n    const encodedSep = encodeString(sep);\r\n\r\n    pairs.forEach(([pk, pv]) => {\r\n      let tmp = \"\";\r\n      let encValue = \"\";\r\n\r\n      if (pv === undefined) {\r\n        return;\r\n      } else if (Array.isArray(pv)) {\r\n        encValue = mapDefined(pv, (v) => `${encodeValue(v)}`).join(encodedSep);\r\n      } else if (isPlainObject(pv)) {\r\n        encValue = mapDefinedEntries(Object.entries(pv), ([k, v]) => {\r\n          return `${encodeString(k)}${encodedSep}${encodeValue(v)}`;\r\n        }).join(encodedSep);\r\n      } else {\r\n        encValue = `${encodeValue(pv)}`;\r\n      }\r\n\r\n      tmp = `${encodeString(pk)}=${encValue}`;\r\n\r\n      // If we end up with the nothing then skip forward\r\n      if (!tmp || tmp === \"=\") {\r\n        return;\r\n      }\r\n\r\n      out += `&${tmp}`;\r\n    });\r\n\r\n    return out.slice(1);\r\n  };\r\n}\r\n\r\nexport const encodeForm = formEncoder(\",\");\r\nexport const encodeSpaceDelimited = formEncoder(\" \");\r\nexport const encodePipeDelimited = formEncoder(\"|\");\r\n\r\nexport function encodeBodyForm(\r\n  key: string,\r\n  value: unknown,\r\n  options?: { explode?: boolean; charEncoding?: \"percent\" | \"none\" },\r\n): string {\r\n  let out = \"\";\r\n  const pairs: [string, unknown][] = options?.explode\r\n    ? explode(key, value)\r\n    : [[key, value]];\r\n\r\n  const encodeString = (v: string) => {\r\n    return options?.charEncoding === \"percent\" ? encodeURIComponent(v) : v;\r\n  };\r\n\r\n  const encodeValue = (v: unknown) => encodeString(serializeValue(v));\r\n\r\n  pairs.forEach(([pk, pv]) => {\r\n    let tmp = \"\";\r\n    let encValue = \"\";\r\n\r\n    if (pv === undefined) {\r\n      return;\r\n    } else if (Array.isArray(pv)) {\r\n      encValue = JSON.stringify(pv, jsonReplacer);\r\n    } else if (isPlainObject(pv)) {\r\n      encValue = JSON.stringify(pv, jsonReplacer);\r\n    } else {\r\n      encValue = `${encodeValue(pv)}`;\r\n    }\r\n\r\n    tmp = `${encodeString(pk)}=${encValue}`;\r\n\r\n    // If we end up with the nothing then skip forward\r\n    if (!tmp || tmp === \"=\") {\r\n      return;\r\n    }\r\n\r\n    out += `&${tmp}`;\r\n  });\r\n\r\n  return out.slice(1);\r\n}\r\n\r\nexport function encodeDeepObject(\r\n  key: string,\r\n  value: unknown,\r\n  options?: { charEncoding?: \"percent\" | \"none\" },\r\n): string {\r\n  if (value == null) {\r\n    return \"\";\r\n  }\r\n\r\n  if (!isPlainObject(value)) {\r\n    throw new EncodingError(\r\n      `Value of parameter '${key}' which uses deepObject encoding must be an object`,\r\n    );\r\n  }\r\n\r\n  return encodeDeepObjectObject(key, value, options);\r\n}\r\n\r\nexport function encodeDeepObjectObject(\r\n  key: string,\r\n  value: unknown,\r\n  options?: { charEncoding?: \"percent\" | \"none\" },\r\n): string {\r\n  if (value == null) {\r\n    return \"\";\r\n  }\r\n\r\n  let out = \"\";\r\n\r\n  const encodeString = (v: string) => {\r\n    return options?.charEncoding === \"percent\" ? encodeURIComponent(v) : v;\r\n  };\r\n\r\n  if (!isPlainObject(value)) {\r\n    throw new EncodingError(`Expected parameter '${key}' to be an object.`);\r\n  }\r\n\r\n  Object.entries(value).forEach(([ck, cv]) => {\r\n    if (cv === undefined) {\r\n      return;\r\n    }\r\n\r\n    const pk = `${key}[${ck}]`;\r\n\r\n    if (isPlainObject(cv)) {\r\n      const objOut = encodeDeepObjectObject(pk, cv, options);\r\n\r\n      out += `&${objOut}`;\r\n\r\n      return;\r\n    }\r\n\r\n    const pairs: unknown[] = Array.isArray(cv) ? cv : [cv];\r\n    let encoded = \"\";\r\n\r\n    encoded = mapDefined(pairs, (v) => {\r\n      return `${encodeString(pk)}=${encodeString(serializeValue(v))}`;\r\n    }).join(\"&\");\r\n\r\n    out += `&${encoded}`;\r\n  });\r\n\r\n  return out.slice(1);\r\n}\r\n\r\nexport function encodeJSON(\r\n  key: string,\r\n  value: unknown,\r\n  options?: { explode?: boolean; charEncoding?: \"percent\" | \"none\" },\r\n): string {\r\n  if (typeof value === \"undefined\") {\r\n    return \"\";\r\n  }\r\n\r\n  const encodeString = (v: string) => {\r\n    return options?.charEncoding === \"percent\" ? encodeURIComponent(v) : v;\r\n  };\r\n\r\n  const encVal = encodeString(JSON.stringify(value, jsonReplacer));\r\n\r\n  return options?.explode ? encVal : `${encodeString(key)}=${encVal}`;\r\n}\r\n\r\nexport const encodeSimple = (\r\n  key: string,\r\n  value: unknown,\r\n  options?: { explode?: boolean; charEncoding?: \"percent\" | \"none\" },\r\n): string => {\r\n  let out = \"\";\r\n  const pairs: [string, unknown][] = options?.explode\r\n    ? explode(key, value)\r\n    : [[key, value]];\r\n\r\n  const encodeString = (v: string) => {\r\n    return options?.charEncoding === \"percent\" ? encodeURIComponent(v) : v;\r\n  };\r\n  const encodeValue = (v: unknown) => encodeString(serializeValue(v));\r\n\r\n  pairs.forEach(([pk, pv]) => {\r\n    let tmp = \"\";\r\n\r\n    if (pv === undefined) {\r\n      return;\r\n    } else if (Array.isArray(pv)) {\r\n      tmp = mapDefined(pv, (v) => `${encodeValue(v)}`).join(\",\");\r\n    } else if (isPlainObject(pv)) {\r\n      tmp = mapDefinedEntries(Object.entries(pv), ([k, v]) => {\r\n        return `,${encodeString(k)},${encodeValue(v)}`;\r\n      }).join(\"\");\r\n      tmp = tmp.slice(1);\r\n    } else {\r\n      const k = options?.explode && isPlainObject(value) ? `${pk}=` : \"\";\r\n      tmp = `${k}${encodeValue(pv)}`;\r\n    }\r\n\r\n    // If we end up with the nothing then skip forward\r\n    if (!tmp) {\r\n      return;\r\n    }\r\n\r\n    out += `,${tmp}`;\r\n  });\r\n\r\n  return out.slice(1);\r\n};\r\n\r\nfunction explode(key: string, value: unknown): [string, unknown][] {\r\n  if (Array.isArray(value)) {\r\n    return value.map((v) => [key, v]);\r\n  } else if (isPlainObject(value)) {\r\n    const o = value ?? {};\r\n    return Object.entries(o).map(([k, v]) => [k, v]);\r\n  } else {\r\n    return [[key, value]];\r\n  }\r\n}\r\n\r\nfunction serializeValue(value: unknown): string {\r\n  if (value === null) {\r\n    return \"null\";\r\n  } else if (typeof value === \"undefined\") {\r\n    return \"\";\r\n  } else if (value instanceof Date) {\r\n    return value.toISOString();\r\n  } else if (value instanceof Uint8Array) {\r\n    return bytesToBase64(value);\r\n  } else if (typeof value === \"object\") {\r\n    return JSON.stringify(value, jsonReplacer);\r\n  }\r\n\r\n  return `${value}`;\r\n}\r\n\r\nfunction jsonReplacer(_: string, value: unknown): unknown {\r\n  if (value instanceof Uint8Array) {\r\n    return bytesToBase64(value);\r\n  } else {\r\n    return value;\r\n  }\r\n}\r\n\r\nfunction mapDefined<T, R>(inp: T[], mapper: (v: T) => R): R[] {\r\n  return inp.reduce<R[]>((acc, v) => {\r\n    if (v === undefined) {\r\n      return acc;\r\n    }\r\n\r\n    const m = mapper(v);\r\n    if (m === undefined) {\r\n      return acc;\r\n    }\r\n\r\n    acc.push(m);\r\n\r\n    return acc;\r\n  }, []);\r\n}\r\n\r\nfunction mapDefinedEntries<K, V, R>(\r\n  inp: Iterable<[K, V]>,\r\n  mapper: (v: [K, V]) => R,\r\n): R[] {\r\n  const acc: R[] = [];\r\n  for (const [k, v] of inp) {\r\n    if (v === undefined) {\r\n      continue;\r\n    }\r\n\r\n    const m = mapper([k, v]);\r\n    if (m === undefined) {\r\n      continue;\r\n    }\r\n\r\n    acc.push(m);\r\n  }\r\n\r\n  return acc;\r\n}\r\n\r\nexport function queryJoin(...args: string[]): string {\r\n  return args.filter(Boolean).join(\"&\");\r\n}\r\n\r\ntype QueryEncoderOptions = {\r\n  explode?: boolean;\r\n  charEncoding?: \"percent\" | \"none\";\r\n};\r\n\r\ntype QueryEncoder = (\r\n  key: string,\r\n  value: unknown,\r\n  options?: QueryEncoderOptions,\r\n) => string;\r\n\r\ntype BulkQueryEncoder = (\r\n  values: Record<string, unknown>,\r\n  options?: QueryEncoderOptions,\r\n) => string;\r\n\r\nexport function queryEncoder(f: QueryEncoder): BulkQueryEncoder {\r\n  const bulkEncode = function (\r\n    values: Record<string, unknown>,\r\n    options?: QueryEncoderOptions,\r\n  ): string {\r\n    const opts: QueryEncoderOptions = {\r\n      ...options,\r\n      explode: options?.explode ?? true,\r\n      charEncoding: options?.charEncoding ?? \"percent\",\r\n    };\r\n\r\n    const encoded = Object.entries(values).map(([key, value]) => {\r\n      return f(key, value, opts);\r\n    });\r\n    return queryJoin(...encoded);\r\n  };\r\n\r\n  return bulkEncode;\r\n}\r\n\r\nexport const encodeJSONQuery = queryEncoder(encodeJSON);\r\nexport const encodeFormQuery = queryEncoder(encodeForm);\r\nexport const encodeSpaceDelimitedQuery = queryEncoder(encodeSpaceDelimited);\r\nexport const encodePipeDelimitedQuery = queryEncoder(encodePipeDelimited);\r\nexport const encodeDeepObjectQuery = queryEncoder(encodeDeepObject);\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}