{"ast":null,"code":"\"use strict\";\n\n/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readableStreamToArrayBuffer = readableStreamToArrayBuffer;\n/**\n * Consumes a stream and returns a concatenated array buffer. Useful in\n * situations where we need to read the whole file because it forms part of a\n * larger payload containing other fields, and we can't modify the underlying\n * request structure.\n */\nasync function readableStreamToArrayBuffer(readable) {\n  const reader = readable.getReader();\n  const chunks = [];\n  let totalLength = 0;\n  let done = false;\n  while (!done) {\n    const {\n      value,\n      done: doneReading\n    } = await reader.read();\n    if (doneReading) {\n      done = true;\n    } else {\n      chunks.push(value);\n      totalLength += value.length;\n    }\n  }\n  const concatenatedChunks = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const chunk of chunks) {\n    concatenatedChunks.set(chunk, offset);\n    offset += chunk.length;\n  }\n  return concatenatedChunks.buffer;\n}","map":{"version":3,"names":["exports","readableStreamToArrayBuffer","readable","reader","getReader","chunks","totalLength","done","value","doneReading","read","push","length","concatenatedChunks","Uint8Array","offset","chunk","set","buffer"],"sources":["/Users/emilijablinkeviciute/Desktop/REPOS/Visualisers project/final-project-the-visualisers/my-app/node_modules/@mistralai/mistralai/src/lib/files.ts"],"sourcesContent":["/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\n\n/**\n * Consumes a stream and returns a concatenated array buffer. Useful in\n * situations where we need to read the whole file because it forms part of a\n * larger payload containing other fields, and we can't modify the underlying\n * request structure.\n */\nexport async function readableStreamToArrayBuffer(\n  readable: ReadableStream<Uint8Array>,\n): Promise<ArrayBuffer> {\n  const reader = readable.getReader();\n  const chunks: Uint8Array[] = [];\n\n  let totalLength = 0;\n  let done = false;\n\n  while (!done) {\n    const { value, done: doneReading } = await reader.read();\n\n    if (doneReading) {\n      done = true;\n    } else {\n      chunks.push(value);\n      totalLength += value.length;\n    }\n  }\n\n  const concatenatedChunks = new Uint8Array(totalLength);\n  let offset = 0;\n\n  for (const chunk of chunks) {\n    concatenatedChunks.set(chunk, offset);\n    offset += chunk.length;\n  }\n\n  return concatenatedChunks.buffer;\n}\n"],"mappings":";;AAAA;;;;;;AAUAA,OAAA,CAAAC,2BAAA,GAAAA,2BAAA;AANA;;;;;;AAMO,eAAeA,2BAA2BA,CAC/CC,QAAoC;EAEpC,MAAMC,MAAM,GAAGD,QAAQ,CAACE,SAAS,EAAE;EACnC,MAAMC,MAAM,GAAiB,EAAE;EAE/B,IAAIC,WAAW,GAAG,CAAC;EACnB,IAAIC,IAAI,GAAG,KAAK;EAEhB,OAAO,CAACA,IAAI,EAAE;IACZ,MAAM;MAAEC,KAAK;MAAED,IAAI,EAAEE;IAAW,CAAE,GAAG,MAAMN,MAAM,CAACO,IAAI,EAAE;IAExD,IAAID,WAAW,EAAE;MACfF,IAAI,GAAG,IAAI;IACb,CAAC,MAAM;MACLF,MAAM,CAACM,IAAI,CAACH,KAAK,CAAC;MAClBF,WAAW,IAAIE,KAAK,CAACI,MAAM;IAC7B;EACF;EAEA,MAAMC,kBAAkB,GAAG,IAAIC,UAAU,CAACR,WAAW,CAAC;EACtD,IAAIS,MAAM,GAAG,CAAC;EAEd,KAAK,MAAMC,KAAK,IAAIX,MAAM,EAAE;IAC1BQ,kBAAkB,CAACI,GAAG,CAACD,KAAK,EAAED,MAAM,CAAC;IACrCA,MAAM,IAAIC,KAAK,CAACJ,MAAM;EACxB;EAEA,OAAOC,kBAAkB,CAACK,MAAM;AAClC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}