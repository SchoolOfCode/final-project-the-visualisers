{"ast":null,"code":"\"use strict\";\n\n/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SecurityError = exports.SecurityErrorCode = void 0;\nexports.resolveSecurity = resolveSecurity;\nexports.resolveGlobalSecurity = resolveGlobalSecurity;\nexports.extractSecurity = extractSecurity;\nconst env_js_1 = require(\"./env.js\");\nvar SecurityErrorCode;\n(function (SecurityErrorCode) {\n  SecurityErrorCode[\"Incomplete\"] = \"incomplete\";\n  SecurityErrorCode[\"UnrecognisedSecurityType\"] = \"unrecognized_security_type\";\n})(SecurityErrorCode || (exports.SecurityErrorCode = SecurityErrorCode = {}));\nclass SecurityError extends Error {\n  constructor(code, message) {\n    super(message);\n    this.code = code;\n    this.name = \"SecurityError\";\n  }\n  static incomplete() {\n    return new SecurityError(SecurityErrorCode.Incomplete, \"Security requirements not met in order to perform the operation\");\n  }\n  static unrecognizedType(type) {\n    return new SecurityError(SecurityErrorCode.UnrecognisedSecurityType, `Unrecognised security type: ${type}`);\n  }\n}\nexports.SecurityError = SecurityError;\nfunction resolveSecurity(...options) {\n  const state = {\n    basic: {\n      username: \"\",\n      password: \"\"\n    },\n    headers: {},\n    queryParams: {},\n    cookies: {}\n  };\n  const option = options.find(opts => {\n    return opts.every(o => {\n      if (o.value == null) {\n        return false;\n      } else if (o.type === \"http:basic\") {\n        return o.value.username != null || o.value.password != null;\n      } else if (o.type === \"http:custom\") {\n        return null;\n      } else if (typeof o.value === \"string\") {\n        return !!o.value;\n      } else {\n        throw new Error(`Unrecognized security type: ${o.type} (value type: ${typeof o.value})`);\n      }\n    });\n  });\n  if (option == null) {\n    return null;\n  }\n  option.forEach(spec => {\n    if (spec.value == null) {\n      return;\n    }\n    const {\n      type\n    } = spec;\n    switch (type) {\n      case \"apiKey:header\":\n        state.headers[spec.fieldName] = spec.value;\n        break;\n      case \"apiKey:query\":\n        state.queryParams[spec.fieldName] = spec.value;\n        break;\n      case \"apiKey:cookie\":\n        state.cookies[spec.fieldName] = spec.value;\n        break;\n      case \"http:basic\":\n        applyBasic(state, spec);\n        break;\n      case \"http:custom\":\n        break;\n      case \"http:bearer\":\n        applyBearer(state, spec);\n        break;\n      case \"oauth2\":\n        applyBearer(state, spec);\n        break;\n      case \"oauth2:client_credentials\":\n        break;\n      case \"openIdConnect\":\n        applyBearer(state, spec);\n        break;\n      default:\n        spec;\n        throw SecurityError.unrecognizedType(type);\n    }\n  });\n  return state;\n}\nfunction applyBasic(state, spec) {\n  if (spec.value == null) {\n    return;\n  }\n  state.basic = spec.value;\n}\nfunction applyBearer(state, spec) {\n  if (spec.value == null) {\n    return;\n  }\n  let value = spec.value;\n  if (value.slice(0, 7).toLowerCase() !== \"bearer \") {\n    value = `Bearer ${value}`;\n  }\n  state.headers[spec.fieldName] = value;\n}\nfunction resolveGlobalSecurity(security) {\n  var _a;\n  return resolveSecurity([{\n    fieldName: \"Authorization\",\n    type: \"http:bearer\",\n    value: (_a = security === null || security === void 0 ? void 0 : security.apiKey) !== null && _a !== void 0 ? _a : (0, env_js_1.env)().MISTRAL_API_KEY\n  }]);\n}\nasync function extractSecurity(sec) {\n  if (sec == null) {\n    return;\n  }\n  return typeof sec === \"function\" ? sec() : sec;\n}","map":{"version":3,"names":["exports","resolveSecurity","resolveGlobalSecurity","extractSecurity","env_js_1","require","SecurityErrorCode","SecurityError","Error","constructor","code","message","name","incomplete","Incomplete","unrecognizedType","type","UnrecognisedSecurityType","options","state","basic","username","password","headers","queryParams","cookies","option","find","opts","every","o","value","forEach","spec","fieldName","applyBasic","applyBearer","slice","toLowerCase","security","_a","apiKey","env","MISTRAL_API_KEY","sec"],"sources":["/Users/emilijablinkeviciute/Desktop/REPOS/Visualisers project/final-project-the-visualisers/my-app/node_modules/@mistralai/mistralai/src/lib/security.ts"],"sourcesContent":["/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\n\nimport * as components from \"../models/components/index.js\";\nimport { env } from \"./env.js\";\n\nexport enum SecurityErrorCode {\n  Incomplete = \"incomplete\",\n  UnrecognisedSecurityType = \"unrecognized_security_type\",\n}\n\nexport class SecurityError extends Error {\n  constructor(\n    public code: SecurityErrorCode,\n    message: string,\n  ) {\n    super(message);\n    this.name = \"SecurityError\";\n  }\n\n  static incomplete(): SecurityError {\n    return new SecurityError(\n      SecurityErrorCode.Incomplete,\n      \"Security requirements not met in order to perform the operation\",\n    );\n  }\n  static unrecognizedType(type: string): SecurityError {\n    return new SecurityError(\n      SecurityErrorCode.UnrecognisedSecurityType,\n      `Unrecognised security type: ${type}`,\n    );\n  }\n}\n\nexport type SecurityState = {\n  basic: { username?: string | undefined; password?: string | undefined };\n  headers: Record<string, string>;\n  queryParams: Record<string, string>;\n  cookies: Record<string, string>;\n};\n\ntype SecurityInputBasic = {\n  type: \"http:basic\";\n  value:\n    | { username?: string | undefined; password?: string | undefined }\n    | null\n    | undefined;\n};\n\ntype SecurityInputBearer = {\n  type: \"http:bearer\";\n  value: string | null | undefined;\n  fieldName: string;\n};\n\ntype SecurityInputAPIKey = {\n  type: \"apiKey:header\" | \"apiKey:query\" | \"apiKey:cookie\";\n  value: string | null | undefined;\n  fieldName: string;\n};\n\ntype SecurityInputOIDC = {\n  type: \"openIdConnect\";\n  value: string | null | undefined;\n  fieldName: string;\n};\n\ntype SecurityInputOAuth2 = {\n  type: \"oauth2\";\n  value: string | null | undefined;\n  fieldName: string;\n};\n\ntype SecurityInputOAuth2ClientCredentials = {\n  type: \"oauth2:client_credentials\";\n  value: string | null | undefined;\n  fieldName: string;\n};\n\ntype SecurityInputCustom = {\n  type: \"http:custom\";\n  value: any | null | undefined;\n  fieldName: string;\n};\n\nexport type SecurityInput =\n  | SecurityInputBasic\n  | SecurityInputBearer\n  | SecurityInputAPIKey\n  | SecurityInputOAuth2\n  | SecurityInputOAuth2ClientCredentials\n  | SecurityInputOIDC\n  | SecurityInputCustom;\n\nexport function resolveSecurity(\n  ...options: SecurityInput[][]\n): SecurityState | null {\n  const state: SecurityState = {\n    basic: { username: \"\", password: \"\" },\n    headers: {},\n    queryParams: {},\n    cookies: {},\n  };\n\n  const option = options.find((opts) => {\n    return opts.every((o) => {\n      if (o.value == null) {\n        return false;\n      } else if (o.type === \"http:basic\") {\n        return o.value.username != null || o.value.password != null;\n      } else if (o.type === \"http:custom\") {\n        return null;\n      } else if (typeof o.value === \"string\") {\n        return !!o.value;\n      } else {\n        throw new Error(\n          `Unrecognized security type: ${o.type} (value type: ${typeof o\n            .value})`,\n        );\n      }\n    });\n  });\n  if (option == null) {\n    return null;\n  }\n\n  option.forEach((spec) => {\n    if (spec.value == null) {\n      return;\n    }\n\n    const { type } = spec;\n\n    switch (type) {\n      case \"apiKey:header\":\n        state.headers[spec.fieldName] = spec.value;\n        break;\n      case \"apiKey:query\":\n        state.queryParams[spec.fieldName] = spec.value;\n        break;\n      case \"apiKey:cookie\":\n        state.cookies[spec.fieldName] = spec.value;\n        break;\n      case \"http:basic\":\n        applyBasic(state, spec);\n        break;\n      case \"http:custom\":\n        break;\n      case \"http:bearer\":\n        applyBearer(state, spec);\n        break;\n      case \"oauth2\":\n        applyBearer(state, spec);\n        break;\n      case \"oauth2:client_credentials\":\n        break;\n      case \"openIdConnect\":\n        applyBearer(state, spec);\n        break;\n      default:\n        spec satisfies never;\n        throw SecurityError.unrecognizedType(type);\n    }\n  });\n\n  return state;\n}\n\nfunction applyBasic(\n  state: SecurityState,\n  spec: SecurityInputBasic,\n) {\n  if (spec.value == null) {\n    return;\n  }\n\n  state.basic = spec.value;\n}\n\nfunction applyBearer(\n  state: SecurityState,\n  spec: SecurityInputBearer | SecurityInputOAuth2 | SecurityInputOIDC,\n) {\n  if (spec.value == null) {\n    return;\n  }\n\n  let value = spec.value;\n  if (value.slice(0, 7).toLowerCase() !== \"bearer \") {\n    value = `Bearer ${value}`;\n  }\n\n  state.headers[spec.fieldName] = value;\n}\nexport function resolveGlobalSecurity(\n  security: Partial<components.Security> | null | undefined,\n): SecurityState | null {\n  return resolveSecurity(\n    [\n      {\n        fieldName: \"Authorization\",\n        type: \"http:bearer\",\n        value: security?.apiKey ?? env().MISTRAL_API_KEY,\n      },\n    ],\n  );\n}\n\nexport async function extractSecurity<\n  T extends string | Record<string, unknown>,\n>(sec: T | (() => Promise<T>) | undefined): Promise<T | undefined> {\n  if (sec == null) {\n    return;\n  }\n\n  return typeof sec === \"function\" ? sec() : sec;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}