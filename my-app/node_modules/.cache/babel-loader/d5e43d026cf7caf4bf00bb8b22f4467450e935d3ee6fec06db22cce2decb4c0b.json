{"ast":null,"code":"\"use strict\";\n\n/*\r\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SecurityError = exports.SecurityErrorCode = void 0;\nexports.resolveSecurity = resolveSecurity;\nexports.resolveGlobalSecurity = resolveGlobalSecurity;\nexports.extractSecurity = extractSecurity;\nconst env_js_1 = require(\"./env.js\");\nvar SecurityErrorCode;\n(function (SecurityErrorCode) {\n  SecurityErrorCode[\"Incomplete\"] = \"incomplete\";\n  SecurityErrorCode[\"UnrecognisedSecurityType\"] = \"unrecognized_security_type\";\n})(SecurityErrorCode || (exports.SecurityErrorCode = SecurityErrorCode = {}));\nclass SecurityError extends Error {\n  constructor(code, message) {\n    super(message);\n    this.code = code;\n    this.name = \"SecurityError\";\n  }\n  static incomplete() {\n    return new SecurityError(SecurityErrorCode.Incomplete, \"Security requirements not met in order to perform the operation\");\n  }\n  static unrecognizedType(type) {\n    return new SecurityError(SecurityErrorCode.UnrecognisedSecurityType, `Unrecognised security type: ${type}`);\n  }\n}\nexports.SecurityError = SecurityError;\nfunction resolveSecurity(...options) {\n  const state = {\n    basic: {\n      username: \"\",\n      password: \"\"\n    },\n    headers: {},\n    queryParams: {},\n    cookies: {}\n  };\n  const option = options.find(opts => {\n    return opts.every(o => {\n      if (o.value == null) {\n        return false;\n      } else if (o.type === \"http:basic\") {\n        return o.value.username != null || o.value.password != null;\n      } else if (o.type === \"http:custom\") {\n        return null;\n      } else if (typeof o.value === \"string\") {\n        return !!o.value;\n      } else {\n        throw new Error(`Unrecognized security type: ${o.type} (value type: ${typeof o.value})`);\n      }\n    });\n  });\n  if (option == null) {\n    return null;\n  }\n  option.forEach(spec => {\n    if (spec.value == null) {\n      return;\n    }\n    const {\n      type\n    } = spec;\n    switch (type) {\n      case \"apiKey:header\":\n        state.headers[spec.fieldName] = spec.value;\n        break;\n      case \"apiKey:query\":\n        state.queryParams[spec.fieldName] = spec.value;\n        break;\n      case \"apiKey:cookie\":\n        state.cookies[spec.fieldName] = spec.value;\n        break;\n      case \"http:basic\":\n        applyBasic(state, spec);\n        break;\n      case \"http:custom\":\n        break;\n      case \"http:bearer\":\n        applyBearer(state, spec);\n        break;\n      case \"oauth2\":\n        applyBearer(state, spec);\n        break;\n      case \"oauth2:client_credentials\":\n        break;\n      case \"openIdConnect\":\n        applyBearer(state, spec);\n        break;\n      default:\n        spec;\n        throw SecurityError.unrecognizedType(type);\n    }\n  });\n  return state;\n}\nfunction applyBasic(state, spec) {\n  if (spec.value == null) {\n    return;\n  }\n  state.basic = spec.value;\n}\nfunction applyBearer(state, spec) {\n  if (spec.value == null) {\n    return;\n  }\n  let value = spec.value;\n  if (value.slice(0, 7).toLowerCase() !== \"bearer \") {\n    value = `Bearer ${value}`;\n  }\n  state.headers[spec.fieldName] = value;\n}\nfunction resolveGlobalSecurity(security) {\n  var _a;\n  return resolveSecurity([{\n    fieldName: \"Authorization\",\n    type: \"http:bearer\",\n    value: (_a = security === null || security === void 0 ? void 0 : security.apiKey) !== null && _a !== void 0 ? _a : (0, env_js_1.env)().MISTRAL_API_KEY\n  }]);\n}\nasync function extractSecurity(sec) {\n  if (sec == null) {\n    return;\n  }\n  return typeof sec === \"function\" ? sec() : sec;\n}","map":{"version":3,"names":["exports","resolveSecurity","resolveGlobalSecurity","extractSecurity","env_js_1","require","SecurityErrorCode","SecurityError","Error","constructor","code","message","name","incomplete","Incomplete","unrecognizedType","type","UnrecognisedSecurityType","options","state","basic","username","password","headers","queryParams","cookies","option","find","opts","every","o","value","forEach","spec","fieldName","applyBasic","applyBearer","slice","toLowerCase","security","_a","apiKey","env","MISTRAL_API_KEY","sec"],"sources":["C:\\Users\\silvi\\OneDrive\\Escritorio\\LUISDEEEE\\School of code\\WEEK 12 FINAL HACKATON\\HistoriansRule\\node_modules\\@mistralai\\mistralai\\src\\lib\\security.ts"],"sourcesContent":["/*\r\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\r\n */\r\n\r\nimport * as components from \"../models/components/index.js\";\r\nimport { env } from \"./env.js\";\r\n\r\nexport enum SecurityErrorCode {\r\n  Incomplete = \"incomplete\",\r\n  UnrecognisedSecurityType = \"unrecognized_security_type\",\r\n}\r\n\r\nexport class SecurityError extends Error {\r\n  constructor(\r\n    public code: SecurityErrorCode,\r\n    message: string,\r\n  ) {\r\n    super(message);\r\n    this.name = \"SecurityError\";\r\n  }\r\n\r\n  static incomplete(): SecurityError {\r\n    return new SecurityError(\r\n      SecurityErrorCode.Incomplete,\r\n      \"Security requirements not met in order to perform the operation\",\r\n    );\r\n  }\r\n  static unrecognizedType(type: string): SecurityError {\r\n    return new SecurityError(\r\n      SecurityErrorCode.UnrecognisedSecurityType,\r\n      `Unrecognised security type: ${type}`,\r\n    );\r\n  }\r\n}\r\n\r\nexport type SecurityState = {\r\n  basic: { username?: string | undefined; password?: string | undefined };\r\n  headers: Record<string, string>;\r\n  queryParams: Record<string, string>;\r\n  cookies: Record<string, string>;\r\n};\r\n\r\ntype SecurityInputBasic = {\r\n  type: \"http:basic\";\r\n  value:\r\n    | { username?: string | undefined; password?: string | undefined }\r\n    | null\r\n    | undefined;\r\n};\r\n\r\ntype SecurityInputBearer = {\r\n  type: \"http:bearer\";\r\n  value: string | null | undefined;\r\n  fieldName: string;\r\n};\r\n\r\ntype SecurityInputAPIKey = {\r\n  type: \"apiKey:header\" | \"apiKey:query\" | \"apiKey:cookie\";\r\n  value: string | null | undefined;\r\n  fieldName: string;\r\n};\r\n\r\ntype SecurityInputOIDC = {\r\n  type: \"openIdConnect\";\r\n  value: string | null | undefined;\r\n  fieldName: string;\r\n};\r\n\r\ntype SecurityInputOAuth2 = {\r\n  type: \"oauth2\";\r\n  value: string | null | undefined;\r\n  fieldName: string;\r\n};\r\n\r\ntype SecurityInputOAuth2ClientCredentials = {\r\n  type: \"oauth2:client_credentials\";\r\n  value: string | null | undefined;\r\n  fieldName: string;\r\n};\r\n\r\ntype SecurityInputCustom = {\r\n  type: \"http:custom\";\r\n  value: any | null | undefined;\r\n  fieldName: string;\r\n};\r\n\r\nexport type SecurityInput =\r\n  | SecurityInputBasic\r\n  | SecurityInputBearer\r\n  | SecurityInputAPIKey\r\n  | SecurityInputOAuth2\r\n  | SecurityInputOAuth2ClientCredentials\r\n  | SecurityInputOIDC\r\n  | SecurityInputCustom;\r\n\r\nexport function resolveSecurity(\r\n  ...options: SecurityInput[][]\r\n): SecurityState | null {\r\n  const state: SecurityState = {\r\n    basic: { username: \"\", password: \"\" },\r\n    headers: {},\r\n    queryParams: {},\r\n    cookies: {},\r\n  };\r\n\r\n  const option = options.find((opts) => {\r\n    return opts.every((o) => {\r\n      if (o.value == null) {\r\n        return false;\r\n      } else if (o.type === \"http:basic\") {\r\n        return o.value.username != null || o.value.password != null;\r\n      } else if (o.type === \"http:custom\") {\r\n        return null;\r\n      } else if (typeof o.value === \"string\") {\r\n        return !!o.value;\r\n      } else {\r\n        throw new Error(\r\n          `Unrecognized security type: ${o.type} (value type: ${typeof o\r\n            .value})`,\r\n        );\r\n      }\r\n    });\r\n  });\r\n  if (option == null) {\r\n    return null;\r\n  }\r\n\r\n  option.forEach((spec) => {\r\n    if (spec.value == null) {\r\n      return;\r\n    }\r\n\r\n    const { type } = spec;\r\n\r\n    switch (type) {\r\n      case \"apiKey:header\":\r\n        state.headers[spec.fieldName] = spec.value;\r\n        break;\r\n      case \"apiKey:query\":\r\n        state.queryParams[spec.fieldName] = spec.value;\r\n        break;\r\n      case \"apiKey:cookie\":\r\n        state.cookies[spec.fieldName] = spec.value;\r\n        break;\r\n      case \"http:basic\":\r\n        applyBasic(state, spec);\r\n        break;\r\n      case \"http:custom\":\r\n        break;\r\n      case \"http:bearer\":\r\n        applyBearer(state, spec);\r\n        break;\r\n      case \"oauth2\":\r\n        applyBearer(state, spec);\r\n        break;\r\n      case \"oauth2:client_credentials\":\r\n        break;\r\n      case \"openIdConnect\":\r\n        applyBearer(state, spec);\r\n        break;\r\n      default:\r\n        spec satisfies never;\r\n        throw SecurityError.unrecognizedType(type);\r\n    }\r\n  });\r\n\r\n  return state;\r\n}\r\n\r\nfunction applyBasic(\r\n  state: SecurityState,\r\n  spec: SecurityInputBasic,\r\n) {\r\n  if (spec.value == null) {\r\n    return;\r\n  }\r\n\r\n  state.basic = spec.value;\r\n}\r\n\r\nfunction applyBearer(\r\n  state: SecurityState,\r\n  spec: SecurityInputBearer | SecurityInputOAuth2 | SecurityInputOIDC,\r\n) {\r\n  if (spec.value == null) {\r\n    return;\r\n  }\r\n\r\n  let value = spec.value;\r\n  if (value.slice(0, 7).toLowerCase() !== \"bearer \") {\r\n    value = `Bearer ${value}`;\r\n  }\r\n\r\n  state.headers[spec.fieldName] = value;\r\n}\r\nexport function resolveGlobalSecurity(\r\n  security: Partial<components.Security> | null | undefined,\r\n): SecurityState | null {\r\n  return resolveSecurity(\r\n    [\r\n      {\r\n        fieldName: \"Authorization\",\r\n        type: \"http:bearer\",\r\n        value: security?.apiKey ?? env().MISTRAL_API_KEY,\r\n      },\r\n    ],\r\n  );\r\n}\r\n\r\nexport async function extractSecurity<\r\n  T extends string | Record<string, unknown>,\r\n>(sec: T | (() => Promise<T>) | undefined): Promise<T | undefined> {\r\n  if (sec == null) {\r\n    return;\r\n  }\r\n\r\n  return typeof sec === \"function\" ? sec() : sec;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}