{"ast":null,"code":"\"use strict\";\n\n/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fimStream = fimStream;\nconst z = __importStar(require(\"zod\"));\nconst encodings_js_1 = require(\"../lib/encodings.js\");\nconst event_streams_js_1 = require(\"../lib/event-streams.js\");\nconst m$ = __importStar(require(\"../lib/matchers.js\"));\nconst schemas$ = __importStar(require(\"../lib/schemas.js\"));\nconst security_js_1 = require(\"../lib/security.js\");\nconst url_js_1 = require(\"../lib/url.js\");\nconst components = __importStar(require(\"../models/components/index.js\"));\nconst errors = __importStar(require(\"../models/errors/index.js\"));\n/**\n * Stream fim completion\n *\n * @remarks\n * Mistral AI provides the ability to stream responses back to a client in order to allow partial results for certain requests. Tokens will be sent as data-only server-sent events as they become available, with the stream terminated by a data: [DONE] message. Otherwise, the server will hold the request open until the timeout or until completion, with the response containing the full result as JSON.\n */\nasync function fimStream(client$, request, options) {\n  const input$ = request;\n  const parsed$ = schemas$.safeParse(input$, value$ => components.FIMCompletionStreamRequest$outboundSchema.parse(value$), \"Input validation failed\");\n  if (!parsed$.ok) {\n    return parsed$;\n  }\n  const payload$ = parsed$.value;\n  const body$ = (0, encodings_js_1.encodeJSON)(\"body\", payload$, {\n    explode: true\n  });\n  const path$ = (0, url_js_1.pathToFunc)(\"/v1/fim/completions#stream\")();\n  const headers$ = new Headers({\n    \"Content-Type\": \"application/json\",\n    Accept: \"text/event-stream\"\n  });\n  const apiKey$ = await (0, security_js_1.extractSecurity)(client$.options$.apiKey);\n  const security$ = apiKey$ == null ? {} : {\n    apiKey: apiKey$\n  };\n  const context = {\n    operationID: \"stream_fim\",\n    oAuth2Scopes: [],\n    securitySource: client$.options$.apiKey\n  };\n  const securitySettings$ = (0, security_js_1.resolveGlobalSecurity)(security$);\n  const requestRes = client$.createRequest$(context, {\n    security: securitySettings$,\n    method: \"POST\",\n    path: path$,\n    headers: headers$,\n    body: body$,\n    timeoutMs: (options === null || options === void 0 ? void 0 : options.timeoutMs) || client$.options$.timeoutMs || -1\n  }, options);\n  if (!requestRes.ok) {\n    return requestRes;\n  }\n  const request$ = requestRes.value;\n  const doResult = await client$.do$(request$, {\n    context,\n    errorCodes: [\"422\", \"4XX\", \"5XX\"],\n    retryConfig: (options === null || options === void 0 ? void 0 : options.retries) || client$.options$.retryConfig,\n    retryCodes: (options === null || options === void 0 ? void 0 : options.retryCodes) || [\"429\", \"500\", \"502\", \"503\", \"504\"]\n  });\n  if (!doResult.ok) {\n    return doResult;\n  }\n  const response = doResult.value;\n  const responseFields$ = {\n    HttpMeta: {\n      Response: response,\n      Request: request$\n    }\n  };\n  const [result$] = await m$.match(m$.sse(200, z.instanceof(ReadableStream).transform(stream => {\n    return new event_streams_js_1.EventStream({\n      stream,\n      decoder(rawEvent) {\n        const schema = components.CompletionEvent$inboundSchema;\n        return schema.parse(rawEvent);\n      }\n    });\n  }), {\n    sseSentinel: \"[DONE]\"\n  }), m$.jsonErr(422, errors.HTTPValidationError$inboundSchema), m$.fail([\"4XX\", \"5XX\"]))(response, {\n    extraFields: responseFields$\n  });\n  if (!result$.ok) {\n    return result$;\n  }\n  return result$;\n}","map":{"version":3,"names":["exports","fimStream","z","__importStar","require","encodings_js_1","event_streams_js_1","m$","schemas$","security_js_1","url_js_1","components","errors","client$","request","options","input$","parsed$","safeParse","value$","FIMCompletionStreamRequest$outboundSchema","parse","ok","payload$","value","body$","encodeJSON","explode","path$","pathToFunc","headers$","Headers","Accept","apiKey$","extractSecurity","options$","apiKey","security$","context","operationID","oAuth2Scopes","securitySource","securitySettings$","resolveGlobalSecurity","requestRes","createRequest$","security","method","path","headers","body","timeoutMs","request$","doResult","do$","errorCodes","retryConfig","retries","retryCodes","response","responseFields$","HttpMeta","Response","Request","result$","match","sse","instanceof","ReadableStream","transform","stream","EventStream","decoder","rawEvent","schema","CompletionEvent$inboundSchema","sseSentinel","jsonErr","HTTPValidationError$inboundSchema","fail","extraFields"],"sources":["/Users/emilijablinkeviciute/Desktop/REPOS/Visualisers project/final-project-the-visualisers/my-app/node_modules/@mistralai/mistralai/src/funcs/fimStream.ts"],"sourcesContent":["/*\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\n */\n\nimport * as z from \"zod\";\nimport { MistralCore } from \"../core.js\";\nimport { encodeJSON as encodeJSON$ } from \"../lib/encodings.js\";\nimport { EventStream } from \"../lib/event-streams.js\";\nimport * as m$ from \"../lib/matchers.js\";\nimport * as schemas$ from \"../lib/schemas.js\";\nimport { RequestOptions } from \"../lib/sdks.js\";\nimport { extractSecurity, resolveGlobalSecurity } from \"../lib/security.js\";\nimport { pathToFunc } from \"../lib/url.js\";\nimport * as components from \"../models/components/index.js\";\nimport {\n  ConnectionError,\n  InvalidRequestError,\n  RequestAbortedError,\n  RequestTimeoutError,\n  UnexpectedClientError,\n} from \"../models/errors/httpclienterrors.js\";\nimport * as errors from \"../models/errors/index.js\";\nimport { SDKError } from \"../models/errors/sdkerror.js\";\nimport { SDKValidationError } from \"../models/errors/sdkvalidationerror.js\";\nimport { Result } from \"../types/fp.js\";\n\n/**\n * Stream fim completion\n *\n * @remarks\n * Mistral AI provides the ability to stream responses back to a client in order to allow partial results for certain requests. Tokens will be sent as data-only server-sent events as they become available, with the stream terminated by a data: [DONE] message. Otherwise, the server will hold the request open until the timeout or until completion, with the response containing the full result as JSON.\n */\nexport async function fimStream(\n  client$: MistralCore,\n  request: components.FIMCompletionStreamRequest,\n  options?: RequestOptions,\n): Promise<\n  Result<\n    EventStream<components.CompletionEvent>,\n    | errors.HTTPValidationError\n    | SDKError\n    | SDKValidationError\n    | UnexpectedClientError\n    | InvalidRequestError\n    | RequestAbortedError\n    | RequestTimeoutError\n    | ConnectionError\n  >\n> {\n  const input$ = request;\n\n  const parsed$ = schemas$.safeParse(\n    input$,\n    (value$) =>\n      components.FIMCompletionStreamRequest$outboundSchema.parse(value$),\n    \"Input validation failed\",\n  );\n  if (!parsed$.ok) {\n    return parsed$;\n  }\n  const payload$ = parsed$.value;\n  const body$ = encodeJSON$(\"body\", payload$, { explode: true });\n\n  const path$ = pathToFunc(\"/v1/fim/completions#stream\")();\n\n  const headers$ = new Headers({\n    \"Content-Type\": \"application/json\",\n    Accept: \"text/event-stream\",\n  });\n\n  const apiKey$ = await extractSecurity(client$.options$.apiKey);\n  const security$ = apiKey$ == null ? {} : { apiKey: apiKey$ };\n  const context = {\n    operationID: \"stream_fim\",\n    oAuth2Scopes: [],\n    securitySource: client$.options$.apiKey,\n  };\n  const securitySettings$ = resolveGlobalSecurity(security$);\n\n  const requestRes = client$.createRequest$(context, {\n    security: securitySettings$,\n    method: \"POST\",\n    path: path$,\n    headers: headers$,\n    body: body$,\n    timeoutMs: options?.timeoutMs || client$.options$.timeoutMs || -1,\n  }, options);\n  if (!requestRes.ok) {\n    return requestRes;\n  }\n  const request$ = requestRes.value;\n\n  const doResult = await client$.do$(request$, {\n    context,\n    errorCodes: [\"422\", \"4XX\", \"5XX\"],\n    retryConfig: options?.retries\n      || client$.options$.retryConfig,\n    retryCodes: options?.retryCodes || [\"429\", \"500\", \"502\", \"503\", \"504\"],\n  });\n  if (!doResult.ok) {\n    return doResult;\n  }\n  const response = doResult.value;\n\n  const responseFields$ = {\n    HttpMeta: { Response: response, Request: request$ },\n  };\n\n  const [result$] = await m$.match<\n    EventStream<components.CompletionEvent>,\n    | errors.HTTPValidationError\n    | SDKError\n    | SDKValidationError\n    | UnexpectedClientError\n    | InvalidRequestError\n    | RequestAbortedError\n    | RequestTimeoutError\n    | ConnectionError\n  >(\n    m$.sse(\n      200,\n      z.instanceof(ReadableStream<Uint8Array>).transform(stream => {\n        return new EventStream({\n          stream,\n          decoder(rawEvent) {\n            const schema = components.CompletionEvent$inboundSchema;\n            return schema.parse(rawEvent);\n          },\n        });\n      }),\n      { sseSentinel: \"[DONE]\" },\n    ),\n    m$.jsonErr(422, errors.HTTPValidationError$inboundSchema),\n    m$.fail([\"4XX\", \"5XX\"]),\n  )(response, { extraFields: responseFields$ });\n  if (!result$.ok) {\n    return result$;\n  }\n\n  return result$;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}