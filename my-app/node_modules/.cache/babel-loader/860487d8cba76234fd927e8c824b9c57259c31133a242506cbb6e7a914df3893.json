{"ast":null,"code":"\"use strict\";\n\n/*\r\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HTTPClient = void 0;\nexports.matchContentType = matchContentType;\nexports.matchStatusCode = matchStatusCode;\nexports.matchResponse = matchResponse;\nexports.isConnectionError = isConnectionError;\nexports.isTimeoutError = isTimeoutError;\nexports.isAbortError = isAbortError;\nconst DEFAULT_FETCHER = (input, init) => {\n  // If input is a Request and init is undefined, Bun will discard the method,\n  // headers, body and other options that were set on the request object.\n  // Node.js and browers would ignore an undefined init value. This check is\n  // therefore needed for interop with Bun.\n  if (init == null) {\n    return fetch(input);\n  } else {\n    return fetch(input, init);\n  }\n};\nclass HTTPClient {\n  constructor(options = {}) {\n    this.options = options;\n    this.requestHooks = [];\n    this.requestErrorHooks = [];\n    this.responseHooks = [];\n    this.fetcher = options.fetcher || DEFAULT_FETCHER;\n  }\n  async request(request) {\n    let req = request;\n    for (const hook of this.requestHooks) {\n      const nextRequest = await hook(req);\n      if (nextRequest) {\n        req = nextRequest;\n      }\n    }\n    try {\n      const res = await this.fetcher(req);\n      for (const hook of this.responseHooks) {\n        await hook(res, req);\n      }\n      return res;\n    } catch (err) {\n      for (const hook of this.requestErrorHooks) {\n        await hook(err, req);\n      }\n      throw err;\n    }\n  }\n  addHook(...args) {\n    if (args[0] === \"beforeRequest\") {\n      this.requestHooks.push(args[1]);\n    } else if (args[0] === \"requestError\") {\n      this.requestErrorHooks.push(args[1]);\n    } else if (args[0] === \"response\") {\n      this.responseHooks.push(args[1]);\n    } else {\n      throw new Error(`Invalid hook type: ${args[0]}`);\n    }\n    return this;\n  }\n  removeHook(...args) {\n    let target;\n    if (args[0] === \"beforeRequest\") {\n      target = this.requestHooks;\n    } else if (args[0] === \"requestError\") {\n      target = this.requestErrorHooks;\n    } else if (args[0] === \"response\") {\n      target = this.responseHooks;\n    } else {\n      throw new Error(`Invalid hook type: ${args[0]}`);\n    }\n    const index = target.findIndex(v => v === args[1]);\n    if (index >= 0) {\n      target.splice(index, 1);\n    }\n    return this;\n  }\n  clone() {\n    const child = new HTTPClient(this.options);\n    child.requestHooks = this.requestHooks.slice();\n    child.requestErrorHooks = this.requestErrorHooks.slice();\n    child.responseHooks = this.responseHooks.slice();\n    return child;\n  }\n}\nexports.HTTPClient = HTTPClient;\n// A semicolon surrounded by optional whitespace characters is used to separate\n// segments in a media type string.\nconst mediaParamSeparator = /\\s*;\\s*/g;\nfunction matchContentType(response, pattern) {\n  var _a;\n  // `*` is a special case which means anything is acceptable.\n  if (pattern === \"*\") {\n    return true;\n  }\n  let contentType = ((_a = response.headers.get(\"content-type\")) === null || _a === void 0 ? void 0 : _a.trim()) || \"application/octet-stream\";\n  contentType = contentType.toLowerCase();\n  const wantParts = pattern.toLowerCase().trim().split(mediaParamSeparator);\n  const [wantType = \"\", ...wantParams] = wantParts;\n  if (wantType.split(\"/\").length !== 2) {\n    return false;\n  }\n  const gotParts = contentType.split(mediaParamSeparator);\n  const [gotType = \"\", ...gotParams] = gotParts;\n  const [type = \"\", subtype = \"\"] = gotType.split(\"/\");\n  if (!type || !subtype) {\n    return false;\n  }\n  if (wantType !== \"*/*\" && gotType !== wantType && `${type}/*` !== wantType && `*/${subtype}` !== wantType) {\n    return false;\n  }\n  if (gotParams.length < wantParams.length) {\n    return false;\n  }\n  const params = new Set(gotParams);\n  for (const wantParam of wantParams) {\n    if (!params.has(wantParam)) {\n      return false;\n    }\n  }\n  return true;\n}\nconst codeRangeRE = new RegExp(\"^[0-9]xx$\", \"i\");\nfunction matchStatusCode(response, codes) {\n  const actual = `${response.status}`;\n  const expectedCodes = Array.isArray(codes) ? codes : [codes];\n  if (!expectedCodes.length) {\n    return false;\n  }\n  return expectedCodes.some(ec => {\n    const code = `${ec}`;\n    if (code === \"default\") {\n      return true;\n    }\n    if (!codeRangeRE.test(`${code}`)) {\n      return code === actual;\n    }\n    const expectFamily = code.charAt(0);\n    if (!expectFamily) {\n      throw new Error(\"Invalid status code range\");\n    }\n    const actualFamily = actual.charAt(0);\n    if (!actualFamily) {\n      throw new Error(`Invalid response status code: ${actual}`);\n    }\n    return actualFamily === expectFamily;\n  });\n}\nfunction matchResponse(response, code, contentTypePattern) {\n  return matchStatusCode(response, code) && matchContentType(response, contentTypePattern);\n}\n/**\r\n * Uses various heurisitics to determine if an error is a connection error.\r\n */\nfunction isConnectionError(err) {\n  if (typeof err !== \"object\" || err == null) {\n    return false;\n  }\n  // Covers fetch in Deno as well\n  const isBrowserErr = err instanceof TypeError && err.message.toLowerCase().startsWith(\"failed to fetch\");\n  const isNodeErr = err instanceof TypeError && err.message.toLowerCase().startsWith(\"fetch failed\");\n  const isBunErr = \"name\" in err && err.name === \"ConnectionError\";\n  const isGenericErr = \"code\" in err && typeof err.code === \"string\" && err.code.toLowerCase() === \"econnreset\";\n  return isBrowserErr || isNodeErr || isGenericErr || isBunErr;\n}\n/**\r\n * Uses various heurisitics to determine if an error is a timeout error.\r\n */\nfunction isTimeoutError(err) {\n  if (typeof err !== \"object\" || err == null) {\n    return false;\n  }\n  // Fetch in browser, Node.js, Bun, Deno\n  const isNative = \"name\" in err && err.name === \"TimeoutError\";\n  const isLegacyNative = \"code\" in err && err.code === 23;\n  // Node.js HTTP client and Axios\n  const isGenericErr = \"code\" in err && typeof err.code === \"string\" && err.code.toLowerCase() === \"econnaborted\";\n  return isNative || isLegacyNative || isGenericErr;\n}\n/**\r\n * Uses various heurisitics to determine if an error is a abort error.\r\n */\nfunction isAbortError(err) {\n  if (typeof err !== \"object\" || err == null) {\n    return false;\n  }\n  // Fetch in browser, Node.js, Bun, Deno\n  const isNative = \"name\" in err && err.name === \"AbortError\";\n  const isLegacyNative = \"code\" in err && err.code === 20;\n  // Node.js HTTP client and Axios\n  const isGenericErr = \"code\" in err && typeof err.code === \"string\" && err.code.toLowerCase() === \"econnaborted\";\n  return isNative || isLegacyNative || isGenericErr;\n}","map":{"version":3,"names":["exports","matchContentType","matchStatusCode","matchResponse","isConnectionError","isTimeoutError","isAbortError","DEFAULT_FETCHER","input","init","fetch","HTTPClient","constructor","options","requestHooks","requestErrorHooks","responseHooks","fetcher","request","req","hook","nextRequest","res","err","addHook","args","push","Error","removeHook","target","index","findIndex","v","splice","clone","child","slice","mediaParamSeparator","response","pattern","contentType","_a","headers","get","trim","toLowerCase","wantParts","split","wantType","wantParams","length","gotParts","gotType","gotParams","type","subtype","params","Set","wantParam","has","codeRangeRE","RegExp","codes","actual","status","expectedCodes","Array","isArray","some","ec","code","test","expectFamily","charAt","actualFamily","contentTypePattern","isBrowserErr","TypeError","message","startsWith","isNodeErr","isBunErr","name","isGenericErr","isNative","isLegacyNative"],"sources":["C:\\Users\\silvi\\OneDrive\\Escritorio\\LUISDEEEE\\School of code\\week 13\\final-project-the-visualisers\\node_modules\\@mistralai\\mistralai\\src\\lib\\http.ts"],"sourcesContent":["/*\r\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\r\n */\r\n\r\nexport type Fetcher = (\r\n  input: RequestInfo | URL,\r\n  init?: RequestInit,\r\n) => Promise<Response>;\r\n\r\nexport type Awaitable<T> = T | Promise<T>;\r\n\r\nconst DEFAULT_FETCHER: Fetcher = (input, init) => {\r\n  // If input is a Request and init is undefined, Bun will discard the method,\r\n  // headers, body and other options that were set on the request object.\r\n  // Node.js and browers would ignore an undefined init value. This check is\r\n  // therefore needed for interop with Bun.\r\n  if (init == null) {\r\n    return fetch(input);\r\n  } else {\r\n    return fetch(input, init);\r\n  }\r\n};\r\n\r\nexport type RequestInput = {\r\n  /**\r\n   * The URL the request will use.\r\n   */\r\n  url: URL;\r\n  /**\r\n   * Options used to create a [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request/Request).\r\n   */\r\n  options?: RequestInit | undefined;\r\n};\r\n\r\nexport interface HTTPClientOptions {\r\n  fetcher?: Fetcher;\r\n}\r\n\r\nexport type BeforeRequestHook = (req: Request) => Awaitable<Request | void>;\r\nexport type RequestErrorHook = (err: unknown, req: Request) => Awaitable<void>;\r\nexport type ResponseHook = (res: Response, req: Request) => Awaitable<void>;\r\n\r\nexport class HTTPClient {\r\n  private fetcher: Fetcher;\r\n  private requestHooks: BeforeRequestHook[] = [];\r\n  private requestErrorHooks: RequestErrorHook[] = [];\r\n  private responseHooks: ResponseHook[] = [];\r\n\r\n  constructor(private options: HTTPClientOptions = {}) {\r\n    this.fetcher = options.fetcher || DEFAULT_FETCHER;\r\n  }\r\n\r\n  async request(request: Request): Promise<Response> {\r\n    let req = request;\r\n    for (const hook of this.requestHooks) {\r\n      const nextRequest = await hook(req);\r\n      if (nextRequest) {\r\n        req = nextRequest;\r\n      }\r\n    }\r\n\r\n    try {\r\n      const res = await this.fetcher(req);\r\n\r\n      for (const hook of this.responseHooks) {\r\n        await hook(res, req);\r\n      }\r\n\r\n      return res;\r\n    } catch (err) {\r\n      for (const hook of this.requestErrorHooks) {\r\n        await hook(err, req);\r\n      }\r\n\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Registers a hook that is called before a request is made. The hook function\r\n   * can mutate the request or return a new request. This may be useful to add\r\n   * additional information to request such as request IDs and tracing headers.\r\n   */\r\n  addHook(hook: \"beforeRequest\", fn: BeforeRequestHook): this;\r\n  /**\r\n   * Registers a hook that is called when a request cannot be made due to a\r\n   * network error.\r\n   */\r\n  addHook(hook: \"requestError\", fn: RequestErrorHook): this;\r\n  /**\r\n   * Registers a hook that is called when a response has been received from the\r\n   * server.\r\n   */\r\n  addHook(hook: \"response\", fn: ResponseHook): this;\r\n  addHook(\r\n    ...args:\r\n      | [hook: \"beforeRequest\", fn: BeforeRequestHook]\r\n      | [hook: \"requestError\", fn: RequestErrorHook]\r\n      | [hook: \"response\", fn: ResponseHook]\r\n  ) {\r\n    if (args[0] === \"beforeRequest\") {\r\n      this.requestHooks.push(args[1]);\r\n    } else if (args[0] === \"requestError\") {\r\n      this.requestErrorHooks.push(args[1]);\r\n    } else if (args[0] === \"response\") {\r\n      this.responseHooks.push(args[1]);\r\n    } else {\r\n      throw new Error(`Invalid hook type: ${args[0]}`);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** Removes a hook that was previously registered with `addHook`. */\r\n  removeHook(hook: \"beforeRequest\", fn: BeforeRequestHook): this;\r\n  /** Removes a hook that was previously registered with `addHook`. */\r\n  removeHook(hook: \"requestError\", fn: RequestErrorHook): this;\r\n  /** Removes a hook that was previously registered with `addHook`. */\r\n  removeHook(hook: \"response\", fn: ResponseHook): this;\r\n  removeHook(\r\n    ...args:\r\n      | [hook: \"beforeRequest\", fn: BeforeRequestHook]\r\n      | [hook: \"requestError\", fn: RequestErrorHook]\r\n      | [hook: \"response\", fn: ResponseHook]\r\n  ): this {\r\n    let target: unknown[];\r\n    if (args[0] === \"beforeRequest\") {\r\n      target = this.requestHooks;\r\n    } else if (args[0] === \"requestError\") {\r\n      target = this.requestErrorHooks;\r\n    } else if (args[0] === \"response\") {\r\n      target = this.responseHooks;\r\n    } else {\r\n      throw new Error(`Invalid hook type: ${args[0]}`);\r\n    }\r\n\r\n    const index = target.findIndex((v) => v === args[1]);\r\n    if (index >= 0) {\r\n      target.splice(index, 1);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  clone(): HTTPClient {\r\n    const child = new HTTPClient(this.options);\r\n    child.requestHooks = this.requestHooks.slice();\r\n    child.requestErrorHooks = this.requestErrorHooks.slice();\r\n    child.responseHooks = this.responseHooks.slice();\r\n\r\n    return child;\r\n  }\r\n}\r\n\r\nexport type StatusCodePredicate = number | string | (number | string)[];\r\n\r\n// A semicolon surrounded by optional whitespace characters is used to separate\r\n// segments in a media type string.\r\nconst mediaParamSeparator = /\\s*;\\s*/g;\r\n\r\nexport function matchContentType(response: Response, pattern: string): boolean {\r\n  // `*` is a special case which means anything is acceptable.\r\n  if (pattern === \"*\") {\r\n    return true;\r\n  }\r\n\r\n  let contentType =\r\n    response.headers.get(\"content-type\")?.trim() || \"application/octet-stream\";\r\n  contentType = contentType.toLowerCase();\r\n\r\n  const wantParts = pattern.toLowerCase().trim().split(mediaParamSeparator);\r\n  const [wantType = \"\", ...wantParams] = wantParts;\r\n\r\n  if (wantType.split(\"/\").length !== 2) {\r\n    return false;\r\n  }\r\n\r\n  const gotParts = contentType.split(mediaParamSeparator);\r\n  const [gotType = \"\", ...gotParams] = gotParts;\r\n\r\n  const [type = \"\", subtype = \"\"] = gotType.split(\"/\");\r\n  if (!type || !subtype) {\r\n    return false;\r\n  }\r\n\r\n  if (\r\n    wantType !== \"*/*\" &&\r\n    gotType !== wantType &&\r\n    `${type}/*` !== wantType &&\r\n    `*/${subtype}` !== wantType\r\n  ) {\r\n    return false;\r\n  }\r\n\r\n  if (gotParams.length < wantParams.length) {\r\n    return false;\r\n  }\r\n\r\n  const params = new Set(gotParams);\r\n  for (const wantParam of wantParams) {\r\n    if (!params.has(wantParam)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nconst codeRangeRE = new RegExp(\"^[0-9]xx$\", \"i\");\r\n\r\nexport function matchStatusCode(\r\n  response: Response,\r\n  codes: StatusCodePredicate,\r\n): boolean {\r\n  const actual = `${response.status}`;\r\n  const expectedCodes = Array.isArray(codes) ? codes : [codes];\r\n  if (!expectedCodes.length) {\r\n    return false;\r\n  }\r\n\r\n  return expectedCodes.some((ec) => {\r\n    const code = `${ec}`;\r\n\r\n    if (code === \"default\") {\r\n      return true;\r\n    }\r\n\r\n    if (!codeRangeRE.test(`${code}`)) {\r\n      return code === actual;\r\n    }\r\n\r\n    const expectFamily = code.charAt(0);\r\n    if (!expectFamily) {\r\n      throw new Error(\"Invalid status code range\");\r\n    }\r\n\r\n    const actualFamily = actual.charAt(0);\r\n    if (!actualFamily) {\r\n      throw new Error(`Invalid response status code: ${actual}`);\r\n    }\r\n\r\n    return actualFamily === expectFamily;\r\n  });\r\n}\r\n\r\nexport function matchResponse(\r\n  response: Response,\r\n  code: StatusCodePredicate,\r\n  contentTypePattern: string,\r\n): boolean {\r\n  return (\r\n    matchStatusCode(response, code) &&\r\n    matchContentType(response, contentTypePattern)\r\n  );\r\n}\r\n\r\n/**\r\n * Uses various heurisitics to determine if an error is a connection error.\r\n */\r\nexport function isConnectionError(err: unknown): boolean {\r\n  if (typeof err !== \"object\" || err == null) {\r\n    return false;\r\n  }\r\n\r\n  // Covers fetch in Deno as well\r\n  const isBrowserErr =\r\n    err instanceof TypeError &&\r\n    err.message.toLowerCase().startsWith(\"failed to fetch\");\r\n\r\n  const isNodeErr =\r\n    err instanceof TypeError &&\r\n    err.message.toLowerCase().startsWith(\"fetch failed\");\r\n\r\n  const isBunErr = \"name\" in err && err.name === \"ConnectionError\";\r\n\r\n  const isGenericErr =\r\n    \"code\" in err &&\r\n    typeof err.code === \"string\" &&\r\n    err.code.toLowerCase() === \"econnreset\";\r\n\r\n  return isBrowserErr || isNodeErr || isGenericErr || isBunErr;\r\n}\r\n\r\n/**\r\n * Uses various heurisitics to determine if an error is a timeout error.\r\n */\r\nexport function isTimeoutError(err: unknown): boolean {\r\n  if (typeof err !== \"object\" || err == null) {\r\n    return false;\r\n  }\r\n\r\n  // Fetch in browser, Node.js, Bun, Deno\r\n  const isNative = \"name\" in err && err.name === \"TimeoutError\";\r\n  const isLegacyNative = \"code\" in err && err.code === 23;\r\n\r\n  // Node.js HTTP client and Axios\r\n  const isGenericErr =\r\n    \"code\" in err &&\r\n    typeof err.code === \"string\" &&\r\n    err.code.toLowerCase() === \"econnaborted\";\r\n\r\n  return isNative || isLegacyNative || isGenericErr;\r\n}\r\n\r\n/**\r\n * Uses various heurisitics to determine if an error is a abort error.\r\n */\r\nexport function isAbortError(err: unknown): boolean {\r\n  if (typeof err !== \"object\" || err == null) {\r\n    return false;\r\n  }\r\n\r\n  // Fetch in browser, Node.js, Bun, Deno\r\n  const isNative = \"name\" in err && err.name === \"AbortError\";\r\n  const isLegacyNative = \"code\" in err && err.code === 20;\r\n\r\n  // Node.js HTTP client and Axios\r\n  const isGenericErr =\r\n    \"code\" in err &&\r\n    typeof err.code === \"string\" &&\r\n    err.code.toLowerCase() === \"econnaborted\";\r\n\r\n  return isNative || isLegacyNative || isGenericErr;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}