{"ast":null,"code":"\"use strict\";\n\n/*\r\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readableStreamToArrayBuffer = readableStreamToArrayBuffer;\n/**\r\n * Consumes a stream and returns a concatenated array buffer. Useful in\r\n * situations where we need to read the whole file because it forms part of a\r\n * larger payload containing other fields, and we can't modify the underlying\r\n * request structure.\r\n */\nasync function readableStreamToArrayBuffer(readable) {\n  const reader = readable.getReader();\n  const chunks = [];\n  let totalLength = 0;\n  let done = false;\n  while (!done) {\n    const {\n      value,\n      done: doneReading\n    } = await reader.read();\n    if (doneReading) {\n      done = true;\n    } else {\n      chunks.push(value);\n      totalLength += value.length;\n    }\n  }\n  const concatenatedChunks = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const chunk of chunks) {\n    concatenatedChunks.set(chunk, offset);\n    offset += chunk.length;\n  }\n  return concatenatedChunks.buffer;\n}","map":{"version":3,"names":["exports","readableStreamToArrayBuffer","readable","reader","getReader","chunks","totalLength","done","value","doneReading","read","push","length","concatenatedChunks","Uint8Array","offset","chunk","set","buffer"],"sources":["C:\\Users\\silvi\\OneDrive\\Escritorio\\LUISDEEEE\\School of code\\week 13\\final-project-the-visualisers\\node_modules\\@mistralai\\mistralai\\src\\lib\\files.ts"],"sourcesContent":["/*\r\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\r\n */\r\n\r\n/**\r\n * Consumes a stream and returns a concatenated array buffer. Useful in\r\n * situations where we need to read the whole file because it forms part of a\r\n * larger payload containing other fields, and we can't modify the underlying\r\n * request structure.\r\n */\r\nexport async function readableStreamToArrayBuffer(\r\n  readable: ReadableStream<Uint8Array>,\r\n): Promise<ArrayBuffer> {\r\n  const reader = readable.getReader();\r\n  const chunks: Uint8Array[] = [];\r\n\r\n  let totalLength = 0;\r\n  let done = false;\r\n\r\n  while (!done) {\r\n    const { value, done: doneReading } = await reader.read();\r\n\r\n    if (doneReading) {\r\n      done = true;\r\n    } else {\r\n      chunks.push(value);\r\n      totalLength += value.length;\r\n    }\r\n  }\r\n\r\n  const concatenatedChunks = new Uint8Array(totalLength);\r\n  let offset = 0;\r\n\r\n  for (const chunk of chunks) {\r\n    concatenatedChunks.set(chunk, offset);\r\n    offset += chunk.length;\r\n  }\r\n\r\n  return concatenatedChunks.buffer;\r\n}\r\n"],"mappings":";;AAAA;;;;;;AAUAA,OAAA,CAAAC,2BAAA,GAAAA,2BAAA;AANA;;;;;;AAMO,eAAeA,2BAA2BA,CAC/CC,QAAoC;EAEpC,MAAMC,MAAM,GAAGD,QAAQ,CAACE,SAAS,EAAE;EACnC,MAAMC,MAAM,GAAiB,EAAE;EAE/B,IAAIC,WAAW,GAAG,CAAC;EACnB,IAAIC,IAAI,GAAG,KAAK;EAEhB,OAAO,CAACA,IAAI,EAAE;IACZ,MAAM;MAAEC,KAAK;MAAED,IAAI,EAAEE;IAAW,CAAE,GAAG,MAAMN,MAAM,CAACO,IAAI,EAAE;IAExD,IAAID,WAAW,EAAE;MACfF,IAAI,GAAG,IAAI;IACb,CAAC,MAAM;MACLF,MAAM,CAACM,IAAI,CAACH,KAAK,CAAC;MAClBF,WAAW,IAAIE,KAAK,CAACI,MAAM;IAC7B;EACF;EAEA,MAAMC,kBAAkB,GAAG,IAAIC,UAAU,CAACR,WAAW,CAAC;EACtD,IAAIS,MAAM,GAAG,CAAC;EAEd,KAAK,MAAMC,KAAK,IAAIX,MAAM,EAAE;IAC1BQ,kBAAkB,CAACI,GAAG,CAACD,KAAK,EAAED,MAAM,CAAC;IACrCA,MAAM,IAAIC,KAAK,CAACJ,MAAM;EACxB;EAEA,OAAOC,kBAAkB,CAACK,MAAM;AAClC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}