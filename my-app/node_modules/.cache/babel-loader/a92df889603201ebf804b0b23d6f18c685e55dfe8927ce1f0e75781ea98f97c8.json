{"ast":null,"code":"\"use strict\";\n\n/*\r\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.retry = retry;\nconst http_js_1 = require(\"./http.js\");\nconst defaultBackoff = {\n  initialInterval: 500,\n  maxInterval: 60000,\n  exponent: 1.5,\n  maxElapsedTime: 3600000\n};\nclass PermanentError extends Error {\n  constructor(inner) {\n    super(\"Permanent error\");\n    this.inner = inner;\n    Object.setPrototypeOf(this, PermanentError.prototype);\n  }\n}\nclass TemporaryError extends Error {\n  constructor(res) {\n    super(\"Temporary error\");\n    this.res = res;\n    Object.setPrototypeOf(this, TemporaryError.prototype);\n  }\n}\nasync function retry(fetchFn, options) {\n  var _a;\n  switch (options.config.strategy) {\n    case \"backoff\":\n      return retryBackoff(wrapFetcher(fetchFn, {\n        statusCodes: options.statusCodes,\n        retryConnectionErrors: !!options.config.retryConnectionErrors\n      }), (_a = options.config.backoff) !== null && _a !== void 0 ? _a : defaultBackoff);\n    default:\n      return await fetchFn();\n  }\n}\nfunction wrapFetcher(fn, options) {\n  return async () => {\n    try {\n      const res = await fn();\n      if (isRetryableResponse(res, options.statusCodes)) {\n        throw new TemporaryError(res);\n      }\n      return res;\n    } catch (err) {\n      if (err instanceof TemporaryError) {\n        throw err;\n      }\n      if (options.retryConnectionErrors && ((0, http_js_1.isTimeoutError)(err) || (0, http_js_1.isConnectionError)(err))) {\n        throw err;\n      }\n      throw new PermanentError(err);\n    }\n  };\n}\nconst codeRangeRE = new RegExp(\"^[0-9]xx$\", \"i\");\nfunction isRetryableResponse(res, statusCodes) {\n  const actual = `${res.status}`;\n  return statusCodes.some(code => {\n    if (!codeRangeRE.test(code)) {\n      return code === actual;\n    }\n    const expectFamily = code.charAt(0);\n    if (!expectFamily) {\n      throw new Error(\"Invalid status code range\");\n    }\n    const actualFamily = actual.charAt(0);\n    if (!actualFamily) {\n      throw new Error(`Invalid response status code: ${actual}`);\n    }\n    return actualFamily === expectFamily;\n  });\n}\nasync function retryBackoff(fn, strategy) {\n  const {\n    maxElapsedTime,\n    initialInterval,\n    exponent,\n    maxInterval\n  } = strategy;\n  const start = Date.now();\n  let x = 0;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    try {\n      const res = await fn();\n      return res;\n    } catch (err) {\n      if (err instanceof PermanentError) {\n        throw err.inner;\n      }\n      const elapsed = Date.now() - start;\n      if (elapsed > maxElapsedTime) {\n        if (err instanceof TemporaryError) {\n          return err.res;\n        }\n        throw err;\n      }\n      let retryInterval = 0;\n      if (err instanceof TemporaryError && err.res && err.res.headers) {\n        const retryVal = err.res.headers.get(\"retry-after\") || \"\";\n        if (retryVal != \"\") {\n          const parsedNumber = Number(retryVal);\n          if (!isNaN(parsedNumber) && Number.isInteger(parsedNumber)) {\n            retryInterval = parsedNumber * 1000;\n          } else {\n            const parsedDate = Date.parse(retryVal);\n            if (!isNaN(parsedDate)) {\n              const deltaMS = parsedDate - Date.now();\n              retryInterval = deltaMS > 0 ? Math.ceil(deltaMS) : 0;\n            }\n          }\n        }\n      }\n      if (retryInterval == 0) {\n        retryInterval = initialInterval * Math.pow(x, exponent) + Math.random() * 1000;\n      }\n      const d = Math.min(retryInterval, maxInterval);\n      await delay(d);\n      x++;\n    }\n  }\n}\nasync function delay(delay) {\n  return new Promise(resolve => setTimeout(resolve, delay));\n}","map":{"version":3,"names":["exports","retry","http_js_1","require","defaultBackoff","initialInterval","maxInterval","exponent","maxElapsedTime","PermanentError","Error","constructor","inner","Object","setPrototypeOf","prototype","TemporaryError","res","fetchFn","options","config","strategy","retryBackoff","wrapFetcher","statusCodes","retryConnectionErrors","_a","backoff","fn","isRetryableResponse","err","isTimeoutError","isConnectionError","codeRangeRE","RegExp","actual","status","some","code","test","expectFamily","charAt","actualFamily","start","Date","now","x","elapsed","retryInterval","headers","retryVal","get","parsedNumber","Number","isNaN","isInteger","parsedDate","parse","deltaMS","Math","ceil","pow","random","d","min","delay","Promise","resolve","setTimeout"],"sources":["C:\\Users\\silvi\\OneDrive\\Escritorio\\LUISDEEEE\\School of code\\week 13\\final-project-the-visualisers\\node_modules\\@mistralai\\mistralai\\src\\lib\\retries.ts"],"sourcesContent":["/*\r\n * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.\r\n */\r\n\r\nimport { isConnectionError, isTimeoutError } from \"./http.js\";\r\n\r\nexport type BackoffStrategy = {\r\n  initialInterval: number;\r\n  maxInterval: number;\r\n  exponent: number;\r\n  maxElapsedTime: number;\r\n};\r\n\r\nconst defaultBackoff: BackoffStrategy = {\r\n  initialInterval: 500,\r\n  maxInterval: 60000,\r\n  exponent: 1.5,\r\n  maxElapsedTime: 3600000,\r\n};\r\n\r\nexport type RetryConfig =\r\n  | { strategy: \"none\" }\r\n  | {\r\n      strategy: \"backoff\";\r\n      backoff?: BackoffStrategy;\r\n      retryConnectionErrors?: boolean;\r\n    };\r\n\r\nclass PermanentError extends Error {\r\n  inner: unknown;\r\n\r\n  constructor(inner: unknown) {\r\n    super(\"Permanent error\");\r\n    this.inner = inner;\r\n\r\n    Object.setPrototypeOf(this, PermanentError.prototype);\r\n  }\r\n}\r\n\r\nclass TemporaryError extends Error {\r\n  res: Response;\r\n\r\n  constructor(res: Response) {\r\n    super(\"Temporary error\");\r\n    this.res = res;\r\n\r\n    Object.setPrototypeOf(this, TemporaryError.prototype);\r\n  }\r\n}\r\n\r\nexport async function retry(\r\n  fetchFn: () => Promise<Response>,\r\n  options: {\r\n    config: RetryConfig;\r\n    statusCodes: string[];\r\n  },\r\n): Promise<Response> {\r\n  switch (options.config.strategy) {\r\n    case \"backoff\":\r\n      return retryBackoff(\r\n        wrapFetcher(fetchFn, {\r\n          statusCodes: options.statusCodes,\r\n          retryConnectionErrors: !!options.config.retryConnectionErrors,\r\n        }),\r\n        options.config.backoff ?? defaultBackoff,\r\n      );\r\n    default:\r\n      return await fetchFn();\r\n  }\r\n}\r\n\r\nfunction wrapFetcher(\r\n  fn: () => Promise<Response>,\r\n  options: {\r\n    statusCodes: string[];\r\n    retryConnectionErrors: boolean;\r\n  },\r\n): () => Promise<Response> {\r\n  return async () => {\r\n    try {\r\n      const res = await fn();\r\n      if (isRetryableResponse(res, options.statusCodes)) {\r\n        throw new TemporaryError(res);\r\n      }\r\n\r\n      return res;\r\n    } catch (err) {\r\n      if (err instanceof TemporaryError) {\r\n        throw err;\r\n      }\r\n\r\n      if (\r\n        options.retryConnectionErrors &&\r\n        (isTimeoutError(err) || isConnectionError(err))\r\n      ) {\r\n        throw err;\r\n      }\r\n\r\n      throw new PermanentError(err);\r\n    }\r\n  };\r\n}\r\n\r\nconst codeRangeRE = new RegExp(\"^[0-9]xx$\", \"i\");\r\n\r\nfunction isRetryableResponse(res: Response, statusCodes: string[]): boolean {\r\n  const actual = `${res.status}`;\r\n\r\n  return statusCodes.some((code) => {\r\n    if (!codeRangeRE.test(code)) {\r\n      return code === actual;\r\n    }\r\n\r\n    const expectFamily = code.charAt(0);\r\n    if (!expectFamily) {\r\n      throw new Error(\"Invalid status code range\");\r\n    }\r\n\r\n    const actualFamily = actual.charAt(0);\r\n    if (!actualFamily) {\r\n      throw new Error(`Invalid response status code: ${actual}`);\r\n    }\r\n\r\n    return actualFamily === expectFamily;\r\n  });\r\n}\r\n\r\nasync function retryBackoff(\r\n  fn: () => Promise<Response>,\r\n  strategy: BackoffStrategy,\r\n): Promise<Response> {\r\n  const { maxElapsedTime, initialInterval, exponent, maxInterval } = strategy;\r\n\r\n  const start = Date.now();\r\n  let x = 0;\r\n\r\n  // eslint-disable-next-line no-constant-condition\r\n  while (true) {\r\n    try {\r\n      const res = await fn();\r\n      return res;\r\n    } catch (err) {\r\n      if (err instanceof PermanentError) {\r\n        throw err.inner;\r\n      }\r\n      const elapsed = Date.now() - start;\r\n      if (elapsed > maxElapsedTime) {\r\n        if (err instanceof TemporaryError) {\r\n          return err.res;\r\n        }\r\n\r\n        throw err;\r\n      }\r\n\r\n      let retryInterval = 0;\r\n      if (err instanceof TemporaryError && err.res && err.res.headers) {\r\n        const retryVal = err.res.headers.get(\"retry-after\") || \"\";\r\n        if (retryVal != \"\") {\r\n          const parsedNumber = Number(retryVal);\r\n          if (!isNaN(parsedNumber) && Number.isInteger(parsedNumber)) {\r\n            retryInterval = parsedNumber * 1000;\r\n          } else {\r\n            const parsedDate = Date.parse(retryVal);\r\n            if (!isNaN(parsedDate)) {\r\n              const deltaMS = parsedDate - Date.now();\r\n              retryInterval = deltaMS > 0 ? Math.ceil(deltaMS) : 0;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (retryInterval == 0) {\r\n        retryInterval =\r\n          initialInterval * Math.pow(x, exponent) + Math.random() * 1000;\r\n      }\r\n\r\n      const d = Math.min(retryInterval, maxInterval);\r\n\r\n      await delay(d);\r\n      x++;\r\n    }\r\n  }\r\n}\r\n\r\nasync function delay(delay: number): Promise<void> {\r\n  return new Promise((resolve) => setTimeout(resolve, delay));\r\n}\r\n"],"mappings":";;AAAA;;;;;;AAkDAA,OAAA,CAAAC,KAAA,GAAAA,KAAA;AA9CA,MAAAC,SAAA,GAAAC,OAAA;AASA,MAAMC,cAAc,GAAoB;EACtCC,eAAe,EAAE,GAAG;EACpBC,WAAW,EAAE,KAAK;EAClBC,QAAQ,EAAE,GAAG;EACbC,cAAc,EAAE;CACjB;AAUD,MAAMC,cAAe,SAAQC,KAAK;EAGhCC,YAAYC,KAAc;IACxB,KAAK,CAAC,iBAAiB,CAAC;IACxB,IAAI,CAACA,KAAK,GAAGA,KAAK;IAElBC,MAAM,CAACC,cAAc,CAAC,IAAI,EAAEL,cAAc,CAACM,SAAS,CAAC;EACvD;;AAGF,MAAMC,cAAe,SAAQN,KAAK;EAGhCC,YAAYM,GAAa;IACvB,KAAK,CAAC,iBAAiB,CAAC;IACxB,IAAI,CAACA,GAAG,GAAGA,GAAG;IAEdJ,MAAM,CAACC,cAAc,CAAC,IAAI,EAAEE,cAAc,CAACD,SAAS,CAAC;EACvD;;AAGK,eAAed,KAAKA,CACzBiB,OAAgC,EAChCC,OAGC;;EAED,QAAQA,OAAO,CAACC,MAAM,CAACC,QAAQ;IAC7B,KAAK,SAAS;MACZ,OAAOC,YAAY,CACjBC,WAAW,CAACL,OAAO,EAAE;QACnBM,WAAW,EAAEL,OAAO,CAACK,WAAW;QAChCC,qBAAqB,EAAE,CAAC,CAACN,OAAO,CAACC,MAAM,CAACK;OACzC,CAAC,EACF,CAAAC,EAAA,GAAAP,OAAO,CAACC,MAAM,CAACO,OAAO,cAAAD,EAAA,cAAAA,EAAA,GAAItB,cAAc,CACzC;IACH;MACE,OAAO,MAAMc,OAAO,EAAE;EAC1B;AACF;AAEA,SAASK,WAAWA,CAClBK,EAA2B,EAC3BT,OAGC;EAED,OAAO,YAAW;IAChB,IAAI;MACF,MAAMF,GAAG,GAAG,MAAMW,EAAE,EAAE;MACtB,IAAIC,mBAAmB,CAACZ,GAAG,EAAEE,OAAO,CAACK,WAAW,CAAC,EAAE;QACjD,MAAM,IAAIR,cAAc,CAACC,GAAG,CAAC;MAC/B;MAEA,OAAOA,GAAG;IACZ,CAAC,CAAC,OAAOa,GAAG,EAAE;MACZ,IAAIA,GAAG,YAAYd,cAAc,EAAE;QACjC,MAAMc,GAAG;MACX;MAEA,IACEX,OAAO,CAACM,qBAAqB,KAC5B,IAAAvB,SAAA,CAAA6B,cAAc,EAACD,GAAG,CAAC,IAAI,IAAA5B,SAAA,CAAA8B,iBAAiB,EAACF,GAAG,CAAC,CAAC,EAC/C;QACA,MAAMA,GAAG;MACX;MAEA,MAAM,IAAIrB,cAAc,CAACqB,GAAG,CAAC;IAC/B;EACF,CAAC;AACH;AAEA,MAAMG,WAAW,GAAG,IAAIC,MAAM,CAAC,WAAW,EAAE,GAAG,CAAC;AAEhD,SAASL,mBAAmBA,CAACZ,GAAa,EAAEO,WAAqB;EAC/D,MAAMW,MAAM,GAAG,GAAGlB,GAAG,CAACmB,MAAM,EAAE;EAE9B,OAAOZ,WAAW,CAACa,IAAI,CAAEC,IAAI,IAAI;IAC/B,IAAI,CAACL,WAAW,CAACM,IAAI,CAACD,IAAI,CAAC,EAAE;MAC3B,OAAOA,IAAI,KAAKH,MAAM;IACxB;IAEA,MAAMK,YAAY,GAAGF,IAAI,CAACG,MAAM,CAAC,CAAC,CAAC;IACnC,IAAI,CAACD,YAAY,EAAE;MACjB,MAAM,IAAI9B,KAAK,CAAC,2BAA2B,CAAC;IAC9C;IAEA,MAAMgC,YAAY,GAAGP,MAAM,CAACM,MAAM,CAAC,CAAC,CAAC;IACrC,IAAI,CAACC,YAAY,EAAE;MACjB,MAAM,IAAIhC,KAAK,CAAC,iCAAiCyB,MAAM,EAAE,CAAC;IAC5D;IAEA,OAAOO,YAAY,KAAKF,YAAY;EACtC,CAAC,CAAC;AACJ;AAEA,eAAelB,YAAYA,CACzBM,EAA2B,EAC3BP,QAAyB;EAEzB,MAAM;IAAEb,cAAc;IAAEH,eAAe;IAAEE,QAAQ;IAAED;EAAW,CAAE,GAAGe,QAAQ;EAE3E,MAAMsB,KAAK,GAAGC,IAAI,CAACC,GAAG,EAAE;EACxB,IAAIC,CAAC,GAAG,CAAC;EAET;EACA,OAAO,IAAI,EAAE;IACX,IAAI;MACF,MAAM7B,GAAG,GAAG,MAAMW,EAAE,EAAE;MACtB,OAAOX,GAAG;IACZ,CAAC,CAAC,OAAOa,GAAG,EAAE;MACZ,IAAIA,GAAG,YAAYrB,cAAc,EAAE;QACjC,MAAMqB,GAAG,CAAClB,KAAK;MACjB;MACA,MAAMmC,OAAO,GAAGH,IAAI,CAACC,GAAG,EAAE,GAAGF,KAAK;MAClC,IAAII,OAAO,GAAGvC,cAAc,EAAE;QAC5B,IAAIsB,GAAG,YAAYd,cAAc,EAAE;UACjC,OAAOc,GAAG,CAACb,GAAG;QAChB;QAEA,MAAMa,GAAG;MACX;MAEA,IAAIkB,aAAa,GAAG,CAAC;MACrB,IAAIlB,GAAG,YAAYd,cAAc,IAAIc,GAAG,CAACb,GAAG,IAAIa,GAAG,CAACb,GAAG,CAACgC,OAAO,EAAE;QAC/D,MAAMC,QAAQ,GAAGpB,GAAG,CAACb,GAAG,CAACgC,OAAO,CAACE,GAAG,CAAC,aAAa,CAAC,IAAI,EAAE;QACzD,IAAID,QAAQ,IAAI,EAAE,EAAE;UAClB,MAAME,YAAY,GAAGC,MAAM,CAACH,QAAQ,CAAC;UACrC,IAAI,CAACI,KAAK,CAACF,YAAY,CAAC,IAAIC,MAAM,CAACE,SAAS,CAACH,YAAY,CAAC,EAAE;YAC1DJ,aAAa,GAAGI,YAAY,GAAG,IAAI;UACrC,CAAC,MAAM;YACL,MAAMI,UAAU,GAAGZ,IAAI,CAACa,KAAK,CAACP,QAAQ,CAAC;YACvC,IAAI,CAACI,KAAK,CAACE,UAAU,CAAC,EAAE;cACtB,MAAME,OAAO,GAAGF,UAAU,GAAGZ,IAAI,CAACC,GAAG,EAAE;cACvCG,aAAa,GAAGU,OAAO,GAAG,CAAC,GAAGC,IAAI,CAACC,IAAI,CAACF,OAAO,CAAC,GAAG,CAAC;YACtD;UACF;QACF;MACF;MAEA,IAAIV,aAAa,IAAI,CAAC,EAAE;QACtBA,aAAa,GACX3C,eAAe,GAAGsD,IAAI,CAACE,GAAG,CAACf,CAAC,EAAEvC,QAAQ,CAAC,GAAGoD,IAAI,CAACG,MAAM,EAAE,GAAG,IAAI;MAClE;MAEA,MAAMC,CAAC,GAAGJ,IAAI,CAACK,GAAG,CAAChB,aAAa,EAAE1C,WAAW,CAAC;MAE9C,MAAM2D,KAAK,CAACF,CAAC,CAAC;MACdjB,CAAC,EAAE;IACL;EACF;AACF;AAEA,eAAemB,KAAKA,CAACA,KAAa;EAChC,OAAO,IAAIC,OAAO,CAAEC,OAAO,IAAKC,UAAU,CAACD,OAAO,EAAEF,KAAK,CAAC,CAAC;AAC7D","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}